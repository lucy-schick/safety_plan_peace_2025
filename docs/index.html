<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Safety Plan Peace 2024" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Safety Plan Peace 2024">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gitbook_on":true,"repo_url":"<a href=\"https://github.com/NewGraphEnvironment/mybookdown-template/\" class=\"uri\">https://github.com/NewGraphEnvironment/mybookdown-template/</a>","report_url":"<a href=\"https://newgraphenvironment.github.io/mybookdown-template\" class=\"uri\">https://newgraphenvironment.github.io/mybookdown-template</a>","update_bib":true,"update_packages":false},"title":"Safety Plan Peace 2024"}
</script>

<title>Safety Plan Peace 2024</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
.title {
font-size: 18px;
color: Black;
text-align: center;
}
.author { 
font-size: 13px;
color: Black;
text-align: center;
}
.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Safety Plan Peace 2024</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2024-08-09<br />
Date Revised: 2024-09-08</p>
</div>
<p><br></p>
<p><br></p>
<div id="safety-plan---2024-073-sern-peace-fish-passage" class="section level1 unnumbered break-after-me">
<h1>Safety Plan - 2024-073-sern-peace-fish-passage</h1>
<p>The latest version of this pdf can be downloaded <a href="https://github.com/NewGraphEnvironment/safety_plan_peace_2024/raw/main/docs/safety_plan_sern-peace-fish-passage.pdf">here</a>.</p>
<p><br></p>
<p>The main goal of the fieldwork is baseline monitoring using electrofishing with crews from McLeod Lake. We will be at the six permitted electrofishing sites most of the time. Additionally, we may conduct fish passage (Phase 1) and habitat confirmation (Phase 2) assessments in the Carp and Crooked watershed groups as well. A summary of the potential sites for fish passage assessments, habitat confirmation assessments, and electrofishing is provided in Table <a href="#tab:tab-electrofishing-sites">5</a>, with kml (google earth) and gpx (garmin) files downloadable <a href="https://github.com/NewGraphEnvironment/safety_plan_peace_2024/raw/main/docs/sites_sern-peace-fish-passage_20240908_kml_gpx.zip">here</a>.</p>
<p><br></p>
<p>Georeferenced pdf maps can be accessed and downloaded <a href="https://hillcrestgeo.ca/outgoing/fishpassage/projects/parsnip/">here</a>.</p>
<p><br></p>
<div id="new-graph-employee-information" class="section level2 unnumbered">
<h2>New Graph Employee Information</h2>
<p>Al Irvine<br />
Vehicle: 2013 Toyota Tundra black w/flatdeck and yellow can-am quad<br />
Accommodation: 3396 Rosia Road, Prince George, BC V2K 4Y5</p>
<p><br></p>
<p>Lucy Schick<br />
Vehicle: 2006 Pontiac Vibe red<br />
Accommodation: 6596 Dawson Road, Prince George, BC V2K 5Y4</p>
<p><br></p>
</div>
<div id="crew-members" class="section level2 unnumbered">
<h2>Crew Members</h2>
<p>New Graph Employees Al Irvine and Lucy Schick will be joined by crews from McLoed Lake. All crew member information and emergency contacts can be found below.</p>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-crew">Table 1: </span>Crew members details and emergency contacts
</caption>
<thead>
<tr>
<th style="text-align:left;">
name
</th>
<th style="text-align:left;">
email
</th>
<th style="text-align:left;">
phone
</th>
<th style="text-align:left;">
satellite
</th>
<th style="text-align:left;">
emerg_name
</th>
<th style="text-align:left;">
emerg_email
</th>
<th style="text-align:left;">
emerg_phone
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Allan Irvine
</td>
<td style="text-align:left;">
<a href="mailto:al@newgraphenvironment.com" class="email">al@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-777-1518
</td>
<td style="text-align:left;">
must be contacted by inreach first. Cannot cold call
</td>
<td style="text-align:left;">
Tara Stark
</td>
<td style="text-align:left;">
<a href="mailto:tara@newgraphenvironment.com" class="email">tara@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-505-9854
</td>
</tr>
<tr>
<td style="text-align:left;">
Jillian Isadore
</td>
<td style="text-align:left;">
<a href="mailto:jillianmarie457@icloud.com" class="email">jillianmarie457@icloud.com</a>
</td>
<td style="text-align:left;">
778-349-8471
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Eugenia Isadore
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
 250-644-0418 
</td>
</tr>
<tr>
<td style="text-align:left;">
Tristan Salonas
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Bianca Prince
</td>
<td style="text-align:left;">
<a href="mailto:biancaprince@hotmail.com" class="email">biancaprince@hotmail.com</a>
</td>
<td style="text-align:left;">
250-730-1480
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Nathan Prince
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
250-617-5930
</td>
</tr>
<tr>
<td style="text-align:left;">
John Demont
</td>
<td style="text-align:left;">
<a href="mailto:justjohndumont@icloud.com" class="email">justjohndumont@icloud.com</a>
</td>
<td style="text-align:left;">
250-720-9700
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Nathan Prince
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
250-617-5930
</td>
</tr>
<tr>
<td style="text-align:left;">
Lucy Schick
</td>
<td style="text-align:left;">
<a href="mailto:lucy@newgraphenvironment.com" class="email">lucy@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
604-741-2032
</td>
<td style="text-align:left;">
807-790-9843
</td>
<td style="text-align:left;">
Sa Boothroyd
</td>
<td style="text-align:left;">
<a href="mailto:saboothroyd@gmail.com" class="email">saboothroyd@gmail.com</a>
</td>
<td style="text-align:left;">
604-740-7199
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="equipment-checklists" class="section level2 unnumbered">
<h2>Equipment Checklists</h2>
<p>PLEASE NOTE THAT EQUIPMENT CHECKLISTS ARE PROVIDED FOR THE OVERALL TEAM AND NOT ALL CREWS ARE REQUIRED TO HAVE ALL EQUIPMENT. ALTHOUGH ENCOURAGED FOR ALL ENVIRONMENTAL SCIENCE TECHNICIANS AND MONITORS TO HAVE THE PERSONAL EQUIPMENT NEW GRAPH ENVIRONMENT WILL HAVE ALL EQUIPMENT NECESSARY TO COMPLETE THE WORK.</p>
<p><br></p>
<p>MINIMUM REQUIREMENTS FOR EACH CREW MEMBER INCLUDES GOOD QUALITY AND APPROPRIATELY FITTING LIGHT WEIGHT WADERS AND SEPERATE WADING BOOTS (RUBBER SOLED), HAT, WATER AND A FOOD.</p>
<p><br></p>
<p>MINIMUM REQUIREMENTS FOR FIELD TRUCKS INCLUDE A QUALITY RADIO APPROPRIATE FOR FOREST SERVICE ROADS, OFF-ROAD CAPABLE TIRES IN GOOD CONDITION, SPARE TIRE, JACK, AND TOOLS.</p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:table-equipment">Table 2: </span>Personal Equipment Checklist - SEE NOTE ABOVE FOR MINIMUM REQUIREMENTS
</caption>
<thead>
<tr>
<th style="text-align:left;">
Equipment
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
GPS
</td>
<td style="text-align:left;">
water
</td>
</tr>
<tr>
<td style="text-align:left;">
Suncreen
</td>
<td style="text-align:left;">
food
</td>
</tr>
<tr>
<td style="text-align:left;">
Bugspray
</td>
<td style="text-align:left;">
gloves work
</td>
</tr>
<tr>
<td style="text-align:left;">
Polarized glasses
</td>
<td style="text-align:left;">
headlamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Bear Spray
</td>
<td style="text-align:left;">
clinometer
</td>
</tr>
<tr>
<td style="text-align:left;">
phone/camera
</td>
<td style="text-align:left;">
field vest (surveyors)
</td>
</tr>
<tr>
<td style="text-align:left;">
battery pack booster for phone
</td>
<td style="text-align:left;">
note book
</td>
</tr>
<tr>
<td style="text-align:left;">
Hat
</td>
<td style="text-align:left;">
Extra clothes
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit personal
</td>
<td style="text-align:left;">
rain gear
</td>
</tr>
<tr>
<td style="text-align:left;">
Waders
</td>
<td style="text-align:left;">
hand lens
</td>
</tr>
<tr>
<td style="text-align:left;">
Wading Boots (Rubber-soled only)
</td>
<td style="text-align:left;">
range finder
</td>
</tr>
<tr>
<td style="text-align:left;">
Ski poles
</td>
<td style="text-align:left;">
–
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:equip-crew">Table 3: </span>Crew Equipment Checklist - SEE NOTE ABOVE FOR MINIMUM REQUIREMENTS
</caption>
<thead>
<tr>
<th style="text-align:left;">
Crew Equipment Checklist
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
glasses safety
</td>
<td style="text-align:left;">
tape measure eslon
</td>
</tr>
<tr>
<td style="text-align:left;">
Hand saw
</td>
<td style="text-align:left;">
pilon x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Linesman Gloves x 3
</td>
<td style="text-align:left;">
Measuring board
</td>
</tr>
<tr>
<td style="text-align:left;">
Backroads Mapbook
</td>
<td style="text-align:left;">
Scale
</td>
</tr>
<tr>
<td style="text-align:left;">
Locational maps
</td>
<td style="text-align:left;">
Permits
</td>
</tr>
<tr>
<td style="text-align:left;">
Background Documents
</td>
<td style="text-align:left;">
Fish ID book
</td>
</tr>
<tr>
<td style="text-align:left;">
radio handheld
</td>
<td style="text-align:left;">
Site Cards / Field Guide
</td>
</tr>
<tr>
<td style="text-align:left;">
Satelite communicator
</td>
<td style="text-align:left;">
Minnow Traps
</td>
</tr>
<tr>
<td style="text-align:left;">
Field Safety Plan
</td>
<td style="text-align:left;">
Catfood
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit level 1
</td>
<td style="text-align:left;">
Flagging
</td>
</tr>
<tr>
<td style="text-align:left;">
First Aid binder stocked
</td>
<td style="text-align:left;">
Laptop w/basecamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Throw bags
</td>
<td style="text-align:left;">
GPS cable
</td>
</tr>
<tr>
<td style="text-align:left;">
polaski
</td>
<td style="text-align:left;">
Lazer level
</td>
</tr>
<tr>
<td style="text-align:left;">
shovel
</td>
<td style="text-align:left;">
Assessment cards fish passage
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher backpack
</td>
<td style="text-align:left;">
UAV
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher pressurized
</td>
<td style="text-align:left;">
Flow meter
</td>
</tr>
<tr>
<td style="text-align:left;">
hard hat
</td>
<td style="text-align:left;">
ATV
</td>
</tr>
<tr>
<td style="text-align:left;">
steel toed boots
</td>
<td style="text-align:left;">
bucket rigid x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Battery booster
</td>
<td style="text-align:left;">
bucket foldable
</td>
</tr>
<tr>
<td style="text-align:left;">
Compressor 12V
</td>
<td style="text-align:left;">
clove oil kit w/ instructions
</td>
</tr>
<tr>
<td style="text-align:left;">
Rubber boots (no-slip soles)
</td>
<td style="text-align:left;">
gloves leather
</td>
</tr>
<tr>
<td style="text-align:left;">
Small BT Speaker (for bears)
</td>
<td style="text-align:left;">
sharpies
</td>
</tr>
<tr>
<td style="text-align:left;">
Oakton Multimeter
</td>
<td style="text-align:left;">
ATV gas
</td>
</tr>
<tr>
<td style="text-align:left;">
Backpack Electrofisher
</td>
<td style="text-align:left;">
ATV lock
</td>
</tr>
<tr>
<td style="text-align:left;">
stop nets x 4
</td>
<td style="text-align:left;">
UAV battery charger
</td>
</tr>
<tr>
<td style="text-align:left;">
salt blocks
</td>
<td style="text-align:left;">
wader disinfectant kit
</td>
</tr>
<tr>
<td style="text-align:left;">
loose salt
</td>
<td style="text-align:left;">
GPS batteries
</td>
</tr>
<tr>
<td style="text-align:left;">
dip nets x 2
</td>
<td style="text-align:left;">
ATV helmets
</td>
</tr>
<tr>
<td style="text-align:left;">
tape measure hand
</td>
<td style="text-align:left;">
–
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:equip-truck">Table 4: </span>Truck Equipment Checklist - SEE NOTE ABOVE FOR MINIMUM REQUIREMENTS
</caption>
<thead>
<tr>
<th style="text-align:left;">
Equipment
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Hand saw
</td>
<td style="text-align:left;">
truck/car jack
</td>
</tr>
<tr>
<td style="text-align:left;">
radio truck
</td>
<td style="text-align:left;">
Battery booster
</td>
</tr>
<tr>
<td style="text-align:left;">
polaski
</td>
<td style="text-align:left;">
Compressor 12V
</td>
</tr>
<tr>
<td style="text-align:left;">
shovel
</td>
<td style="text-align:left;">
pilon x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher backpack
</td>
<td style="text-align:left;">
Tow strap
</td>
</tr>
<tr>
<td style="text-align:left;">
truck tow rope
</td>
<td style="text-align:left;">
–
</td>
</tr>
</tbody>
</table></li>
</ul>
</div>
<div id="nearest-hospitals" class="section level2 unnumbered">
<h2>Nearest Hospitals</h2>
<div class="figure"><span style="display:block;" id="fig:hospital-1"></span>
<img src="data:image/png;base64,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" alt="University Hospital of Northern British Columbia - 1475 Edmonton St., Prince George, BC V2M 1S2 - 250-565-2000" width="100%" />
<p class="caption">
Figure 1: University Hospital of Northern British Columbia - 1475 Edmonton St., Prince George, BC V2M 1S2 - 250-565-2000
</p>
</div>
<p><br></p>
</div>
<div id="emergency-response-plan" class="section level2 unnumbered">
<h2>Emergency Response Plan</h2>
<p>New Graph’s detailed emergency response procedures can be found <a href="https://www.newgraphenvironment.com/hsp/plans-and-assessments.html#emergency-response-plan-erp-and-procedures">here</a>. These procedures should be reviewed and an emergency response plan should be completed for each job site. Our Emergency Responce Plan template can be downloaded <a href="https://github.com/NewGraphEnvironment/hsp/blob/master/data/form_templates/ERP_template.pdf">here</a>.</p>
<p><br></p>
</div>
<div id="driving" class="section level2 unnumbered">
<h2>Driving</h2>
<p>We will be driving on forest service roads where it is essential to exercise caution and adhere strictly to all radio use protocols to ensure our safety. Proper communication on these roads helps prevent accidents by keeping everyone informed about vehicle movements and road conditions. Please review the <a href="https://www.newgraphenvironment.com/hsp/safe-work-procedures-and-practices.html#resource-road-safety">resource road safety</a> and <a href="https://www.newgraphenvironment.com/hsp/safe-work-procedures-and-practices.html#radio-use">radio use</a> sections of our Health and Safety plan so that everyone stays safe.</p>
<p><br></p>
</div>
<div id="field-plan" class="section level2 unnumbered">
<h2>Field Plan</h2>
<p>The main goal of the fieldwork is baseline monitoring using electrofishing with crews from McLeod Lake. We will be at the 5 or 6 permitted electrofishing sites most of the time. In addition we may spend some time with fish passage assessments in areas of not only the Parsnip watershed group but also the Carp and Crooked watershed groups.</p>
<p>Field work methods will result in products feeding reporting formats such as <a href="https://www.newgraphenvironment.com/fish_passage_peace_2022_reporting/">here</a> for 2022 and <a href="https://www.newgraphenvironment.com/fish_passage_peace_2023_reporting/">here</a> for 2023. We generally follow procedures in:</p>
<ul>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">fish passage assessments</a> <span class="citation">(BC Ministry of Environment 2011)</span></p></li>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">habitat confirmations</a> <span class="citation">(Fish Passage Technical Working Group 2011)</span>.</p></li>
</ul>
<p><br></p>
<p>Presence/absence of fish, species composition/density and distribution limits can be useful for prioritizing which crossings are a best fit for fish passage restoration and help inform follow up monitoring so electrofishing and minnowtrapping may be conducted. Standard Fish and Fish Habitat Inventory Standard Field Form <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/laws-policies-standards-guidance/inventory-standards/aquatic-ecosystems">site cards</a> are used to gather habitat data, and the Field Guide to these site cards can be found <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/sitecard20.pdf">here</a>.</p>
<p><br></p>
<p>We have PIT tagging equipment so we could consider <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">tagging</a> fish captured at electrofishing sites to help us better understand population sizes and fish movement upstream and downstream of sites over the years.</p>
<p><br></p>
<p>We use digital field form using a product called <a href="https://merginmaps.com/?gclid=Cj0KCQjwxb2XBhDBARIsAOjDZ34oq-iMid3vRrgK1ZAkJ_yiz4aWY-LLF90PHiXzELbZIrxooV9vWKYaAgl2EALw_wcB">Mergin Maps</a> which syncs with QGIS. Please see our <a href="https://www.newgraphenvironment.com/fish_passage_guidebook/">Fish Passage Guidebook</a> for instructions on how to set up Mergin Maps and use our digital field forms. Please send me your usernames and we can begin to share projects/forms.</p>
<p><br></p>
<p>A guide to freshwater fish id such as <span class="citation">McPhail and Carveth (1993)</span> can be useful and can be downloaded <a href="https://a100.gov.bc.ca/pub/acat/documents/r13659/486FieldKeytoFreshwaterFishes1993Part1of2_1210014849226_8e248a8d30d97e6c45ef54a340babd2ffb57b14a3b16.pdf">here</a>.</p>
<!-- and an overview map of displaying potential sample locations is included as Figure 1. -->
<p><br></p>
<div id="check-in-procedures" class="section level3 unnumbered">
<h3>Check In Procedures</h3>
<p>Call, text or inreach Tara Stark (2505059854) each morning to share the plan for the day (i.e. name of roads and sites). Check in time is before 7 pm each evening although we regularly check in throughout the day (ex. at arrival to site, 1pm and 4pm) on the inreach or by text and report position/provide updates.</p>
<p><br></p>
<div id="procedures-for-failed-check-in---for-check-in-person" class="section level4 unnumbered">
<h4>Procedures for Failed Check-In - for Check in person</h4>
<p>Procedures are summarized in the following Figure. If phone call or inReach check-in is not received by 7pm send text to inreach units, call or text cell phones of field crew members. If no response please call accommodations then personal emergency contacts to see if they have heard anything. Wait 1 hour and text inreach, text or call cell phones and personal emergency contacts and accomodations again. Repeat after 2 hours (9 pm) - if no response then notify the RCMP of a missing persons in field.</p>
<p><br></p>
<div class="figure"><span style="display:block;" id="fig:flow-check-in-fail"></span>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA2MAAADlCAYAAADeMC9RAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdd1hTd/s/8HfYewkBQYaICiJOoICAKHVSxSrOKmLxi20d1eexjqd1Vdu66mOtbZU6nlpHHVVxoAwBQZaIMkVkKMoMssImJOf3hxfnRxQtaiCA9+u6uOAkJ+fcCY688/mc+8MBAIZhbgAYC0IIIYQQQgghHS2Mw+G4y0i7CkIIIYQQQgh5H1EYI4QQQgghhBApkJN2Ad1ZbW0t+Hw+qqurwefzUVlZCYZhUFlZye5TX1+PhoaGNh+vrq4OObnnvwI5OTl2W0NDA1paWtDU1IS6ujoUFBQ65fkQQgghhBBCOg+FsVYaGxvx5MkTlJSUoKioCMXFxSgpKUFhYSF4PB4KCwtRVVWFiooK8Pl8KCsrQ0NDQ+xLUVERKioq7DHV1NQgLy/f5vlqa2vR1NTEbldVVUEgELDBjs/ng8/ng8PhsMfncrngcrkwMjICl8tF7969YWBgAH19fRgZGcHQ0BAcDqfDXytCCCGEEELIu3nvwhifz0dmZiZyc3ORk5Mj9p3H48HIyIgNOL179waXy4WLiwu4XC4MDQ2hpaXFjlrJyHTOLM/Gxkbw+XxUVVWBx+OBx+OhoKAAPB4Pt2/fZkNjQUEBysvLYWZmhn79+sHc3Bz9+vVjvywsLF4ZDAkhhBBCCCGdiwP0zG6Kzc3NyMzMRFpaGpKTk5GWlobU1FQ8e/YMAwcOFAsr5ubmMDc3h7GxMWRlZaVd+jtpaGhoM2hmZ2fjyZMn6N+/P2xsbGBjY4MhQ4Zg8ODBMDY2lnbZhBBCCCGEvE/COByOe48JY0+ePEFMTAxiY2MRFxeHtLQ0mJiYiIWOIUOGoG/fvu/tNL7Gxkbcv38fqampYiG1vr4eH3zwARwcHODo6AgHBwdoaGhIu1xCCCGEEEJ6qu4dxlJTUxEaGoqYmBjExMSAYRg4OjrCyckJDg4OGDFiBJSVlaVdZrdQWlqKuLg4xMbGIiYmBnfv3oWZmRkcHR3h7OyM8ePHQ19fX9plEkIIIYQQ0lN0rzBWWlqK0NBQBAcHIzg4GCoqKhg3bhycnZ3h5OQEMzMzaZfYYzQ3NyMlJQUxMTG4efMmwsLCYGJigvHjx2P8+PFwdnaGoqKitMskhBBCCCGku+r6YSwnJwdnzpzB+fPnkZ2djTFjxrCBwNzcXNrlvTeEQiESEhIQFBSE4OBgpKWlYfTo0fDy8oKnpyc0NTWlXSIhhBBCCCHdSdcMY48ePcKZM2dw5swZFBUVYcaMGfDy8sKoUaPYNbmIdFVWVuL69es4c+YMwsLC4OrqipkzZ8LT05OuNSOEEEIIIeSfdZ0wVldXh9OnT8Pf3x+PHj3CjBkzMHPmTLi6unZa+3jydqqrq3H58mWcOXMGERERmDhxIpYsWQI3N7f3tlEKIYQQQggh/0D6YSw9PR0HDx7EyZMn4eTkhCVLlmDixIndvr38+6qqqgonTpzAwYMH0djYiCVLlmDhwoXQ0dGRdmmEEEIIIYR0JWEcDsddKsNOISEhcHNzw4QJE6CtrY179+7h0qVL8PDwoCDWjWlqauKLL75AcnIyjh49iqSkJFhYWGDJkiV49OiRtMsjhBBCCCGkS+nUMBYUFIRRo0Zh5cqV8PPzw+PHj7FlyxZadLgHcnR0xB9//IHs7Gz07t0bH3zwAXx9fZGTkyPt0gghhBBCCOkSOiWM3bx5Ew4ODli9ejVWrFiB1NRUzJs3jxpyvAd0dHSwefNmZGVlwdTUFI6OjvDx8UFBQYG0SyOEEEIIIUSqOjSMFRcXY8GCBfDx8cG///1vJCcnY/bs2dSU4z2kqamJjRs3Ijs7GyYmJhg+fDj27NmD5uZmaZdGCCGEEEKIVHRIKhIKhdi3bx+GDBkCY2NjpKenY+bMmRTCCDQ0NPDtt98iJiYGISEhGDFiBKKioqRdFiGEEEIIIZ1O4umopKQEH374IS5cuIDIyEh8//33UFFRkfRpJIbH4yE9PV0ixxIIBIiMjGz3/qWlpYiJiZHIubsbCwsLXLt2DZs2bcK8efPwzTffQCgUSrssQgghhBBCOo1Ew1hUVBRGjhyJDz74AKGhobC0tJTk4SUuKysLbm5u+PPPP9/5WDU1NVi/fj3Gjx/f7scEBwdj3bp173zu7mzGjBm4d+8e7ty5A3d3dxQXF0u7JEIIIYQQQjqFxMLY/v37MXv2bBw5cgTbt2/vFi3q+/fvDxcXF4kcS01NDT4+Pm/0mE8++eSNRtIkYefOnZ16vvbQ1dVFYGAg3NzcYG9vjzt37ki7JEIIIYQQQjqcRMLYjz/+iJ9//hnx8fFvNDLU2crLyxEeHo6srCz2Ng6HAwDg8/m4efMmysvLxR5TWVmJmJgYPHv2TOx2gUCAhIQE3Lp1q83pdRUVFcjNzUVubi5qampeWVPr9bfq6+uRn5+P6upq3Lx5E7W1ta983MOHDwEASUlJ7M8thEIh7t+/jzt37qChoYG9fcuWLTh8+DASExNRV1f3ymNLg4yMDDZv3oxffvkFU6ZMQWJiorRLIoQQQgghpEO9cxjbu3cv/P39ERYW1qXXCzt9+jROnDgBY2NjzJ49G/v27WPvS01NxdatW3HixAkMHToUfD4fAHDp0iWcOHECPB4PH3zwAa5fvw4AyMvLw+rVq6GmpoagoCC4uLhAJBKJna+hoQGLFy9GXl5emy38Kyoq8O9//xvOzs4AgPT0dFhbW2PVqlXYunUr9uzZAzc3t5ceJxAI8O9//xsjRozAjh07cOLECTg4OODGjRsAgGfPnmH27NkoKyvD48ePMWLECMTFxaGmpgY8Hg/Nzc3Izc1FU1OTRF5XSZsyZQqOHj0KDw8PJCQkSLscQgghhBBCOhbDMDeYt3DkyBGmf//+TH5+/ts8vNPk5eUxY8eOZbeDgoKYAwcOMAzDMEuWLGEWLlzIMAzDiEQiRltbm7l58yZTUVHBuLm5MTk5OUxOTg7j7e3NDB8+nGEYhpk4cSKTlZXFMAzDVFRUMH5+fkxTUxOTmprKKCoqMnl5ecyGDRuYmpqa19YVFBTEGBoasttz5sxhlixZwjAMw5SUlDAAmMLCwpcel5iYyABgKisrGYZhmIULFzIrV65kGIZhFi1axOzYsYPdd8eOHYy5uTnT3NzMHDlyhLG1tX2j105aLl++zPTu3ZvJycmRdimEEEIIIYRI2g0AeOtVl5OTk7Fu3TpERUXByMhIUrmwQ4SEhMDU1JTdfnEqpaamJoDnUxa5XC7KysoQFxfHjiIBwIIFCyAvL4+6ujpERETAwsICAKClpYWDBw+yxxKJRHB3d8exY8egqqrK3n7q1Ck8efIEADBw4EBMmzbtpVb/srKy7GN0dXUBPJ8+2bt375f2A8Duq6enh4qKCgDA9evX4eHhwe47ZcoUrF27ln0eLdMyu7qPPvoIGzZsgJeXF2JjY6GoqCjtkgghhBBCCJGot5qmKBQKsXjxYuzevRsDBgyQdE0SV1NTI3adGICXphW+qKGhAWVlZfjwww/ZL2dnZ1RVVaGhoQGPHz9u83gyMjJYt24d5syZI3admZqaGrS1taGtrS0W0iRNTk4OZWVl7DaXy2VvB7pPGAOAzz//HGZmZtixY4e0SyGEEEIIIUTi3iqM/fHHH1BTU8OCBQskXU+HGDVqFKKjo3H27FkAQF1dHY4fPw7geYhq3YBDJBJBJBLB3t4eubm5+OOPP9j7du/eDS0tLVhZWWH16tUQCAQAgLNnz7IjUwDg6+sLNzc3eHp6or6+HsDzESo/Pz/4+flh3LhxAACGYcAwDPu4V/38T1rvO3nyZFy5coXdzs3NhbW1NczMzKCgoIDGxsZ2H7cr+Pnnn7Fv3z4UFhZKuxRCCCGEEEIk6o3DGMMw2L59O7Zu3doR9XQIW1tbbNmyBXPnzoWlpSVmz54NDw8P8Hg83L17F3fu3AGPx0NaWhqePHmC8PBw6OnpYceOHfD19YW9vT3c3d3h4uICZWVlHD16FNHR0ejTpw/s7e2hqakJNTU1REZGQiAQID4+Hnv37kVmZiZmzZqFp0+fvlRTTU0NIiIiUFZWhtu3b4PH4yE5ORmZmZmorKxESEgIACAiIkLscQzDsPfFx8ejvLwciYmJSE5ORllZGb7//ntUVlbiv//9L3JycvD777/jjz/+AIfDwbBhw/DgwQOsXbtWYgtddzQjIyP4+Phgz5490i6FEEIIIYQQieIAzxt4ABjbngfcunULy5YtQ1JSUocW1hGKi4tRXl4OS0tLyMjIoKKigh3R0tbWRl1dHTty1KdPHygoKKCwsBB5eXkYMmSI2PTC+vp6PHz4EBYWFlBVVUVDQ4PY6A2XywWPxwMAqKiowMDAQKyW6upqlJaWAng+tVFDQwOVlZUAAB0dHVRVVbEjdubm5uzjRCIRO0VSVlYWWlpa7LREHR0daGlpQSQSISkpCdXV1bC1tRWrOzc3F+rq6tDT03v3F7ST5ObmwtHREQUFBW12piSEEEIIIaSbCeNwOO5vHMb+85//QFFREZs2berQ6ghpbcSIEfj111/h4OAg7VIIIYQQQgh5V2EcDsf9jacp3rlzh94Qk07n4OCAO3fuSLsMQgghhBBCJOaNw1h+fj5MTEw6ohZCXsnU1BQFBQXSLoMQQgghhBCJeeMw1tjYCCUlpY6ohZBXUlJSYjtTEkIIIYQQ0hO8cRjT0tJiG00Q0lkqKiqgra0t7TIIIYQQQgiRmDcOYwMHDkRaWlpH1ELIK6WmpsLKykraZRBCCCGEECIxb9wnfNSoUQgLC+s2Cz6/jfLycnz33XfYvn075OXl3/l4ZWVlCA4OhrKyMqZNmyZ2X1ZWFgIDA/HRRx+hX79+b32O1NRUxMbGit2mr68PT0/Ptz5mV9Hc3Ixbt25h79690i6FEEIIIYQQiXnjkbHp06fj8uXLqKur64h6uoTGxkYUFhaiublZIsdjGAb+/v5ITEx86b7a2lqsXr2aXXPsbW3evBkXL15EaGgoQkNDcfjwYYSGhr7TMbuKoKAg9OvXD8bGxtIuhRBCCCGEEIl545Gx3r17Y+zYsfD398fKlSs7oiap6927N06dOiWx4+nq6sLU1BSysrIv3Tds2DCxRZnfBp/Px2effYZx48axt33++eeYPn36Ox23q9i9ezeWLVsm7TIIIYQQQgiRqDcOYwCwceNGjBs3DvPnz4eurq6ka2qXjIwM5OXlQUVFBXfv3sXKlStRU1OD06dPo7i4GF5eXhg4cCC7f3BwMB4/fgyRSAQfHx+2I2RoaCji4uJgbW2NadOmgcPhoK6uDpcuXcK4ceMgIyODY8eOQSAQYPbs2TA2NkZQUBBycnKwePFiKCgoICIiAtHR0RgwYAC8vLzA4XAAANnZ2QgNDYWysjJqa2vZ29vS0NCAX3/9FRUVFZg/fz5MTU0RFRWFjIwM9OrVCx999BGEQiECAgJgamoKJycn9rEaGhpiQUwoFOLWrVvYv38/ACA9PR0PHjyAhYUFTpw4AUtLSyxatAgcDgclJSWIjY2Fi4sLTp06BTU1NXh7eyM5ORmBgYFwdXWFi4uLRH93b+LChQvg8XiYPXu21GoghBBCCCGkI7zxNEUAGDx4MObPn4+lS5dKup52yczMxNy5c7Ft2zbExMQgPDwc1dXVWL16NWbOnAl3d3eMGDEC6enpAIC1a9dCRUUFfn5+uHHjBjvKsmvXLigrK2PlypXYsWMHvvnmGzQ3N+PixYuYO3cuKisroa2tDWVlZezatQuGhoYAAAUFBaiqqkJBQQH79u2DSCTCqlWr8Msvv+Bf//oXACAlJQXr16+Hr68vZsyYgXv37r32OR06dAiysrK4ffs27OzsUFpaipEjR2Lbtm0oKiqCoqIiVFRUEB0djUGDBr32WFFRUXBwcICsrCwKCwuxZs0arF27Fvfu3YO1tTXWr1+PDRs2oKKiAv/617+wfPly/PXXXxgwYAA2bNiApUuX4t69ezA3N8ekSZNQXFz8rr+yt8Lj8bBixQocPHiwzVFFQgghhBBCurO3CmMAsHXrVuTk5OCnn36SZD3tMnDgQIwdOxampqZYt24dAgIC4O/vj5qaGvz1119ISUmBsrIyTpw4gZSUFCQlJcHZ2RnA8wD26aefoqSkBIcPH0Z6ejpOnjwJLpeLw4cPQ05ODjNmzBA736JFiyArK4tr164BACIiIjBnzhxUVFTg559/RnZ2No4fPw49PT0cOXIEDMNgzZo18PHxgby8PNTU1ODg4PDakbEVK1ZgyZIlOHfuHBQUFPC///0PKioqWL16NQ4cOACGYdDU1ARlZWVoaWm99vU5d+4c+xwMDQ3h7u6Ovn37wsfHBwsXLsTOnTtx4MABaGtrw8vLC+rq6li6dCnGjx8Pd3d3KCoq4tNPP8XcuXPRp08fZGZmvsuv660IBALMmzcPPj4+7O+OEEIIIYSQnuStpikCzxfh/fvvvzF69GioqanB19dXknX9I0VFRSgrK7PbCQkJ8PDwYLs8+vn5AQAOHDiAXr16sfuZmZnBzMwMwcHB6N27N7tfy/e2yMvLw8/PDwcPHsTYsWMhLy8PRUVFJCQkQEdH56VjMAyD6Oho/PDDD+wx5ORe/1K3dG2Ul5fH6NGj8fTpUwCAr68vvv32W1y/fh1NTU2YOnXqa48jEokQFhaGPXv2iN3eOgiOGDEC5eXlaGpqeikg9urVCyKRiN1WUVHp9HXlBAIB5syZAw0NDWzevLlTz00IIYQQQkhneeuRMQAwNTXFzZs38d133+HAgQOSqumtqKqqIjo6Wuy2R48eQVlZGXFxcWKdEUtKSqCmpobk5GTU1NSwt1dVVaGsrKzN4/v5+SE0NBT//e9/MWvWLACAmpoa0tPTxcJKbW0teDwegOfXjLX2upGx1mRlZdG/f3/2eS1duhR79uxBfHz8P44S3bp1C7a2tlBQUHjlPjU1Nejbt2+b+8jIvNMfiXcmFAqxcOFC1NfX49SpUzQ9kRBCCCGE9Fjv/M7b1NQUwcHB+OGHH7B7924wDCOJuv6RSCSCUChkt2fMmIGjR4/i7NmzaG5uRnh4OMLCwjBu3Dg8e/YMS5cuxZMnTxAbG4vQ0FDY2tpCXV0dn3/+OSoqKsDj8bBt2zZoaWmxx21oaGCPb2hoiClTpiAiIgIDBgwAANjY2MDIyAiLFy/Gs2fPUFZWhs2bN0NbWxvTpk3D7t272SUA8vLyXtu+vuV1a2howP379+Ht7c3et2zZMsTExEBLS+sfA925c+fa7KLYOjCeP38eX375JXve1iNh1dXVaGxsZLcl1d6/PaqqqvDxxx+jpqYGFy9ehKKiYqedmxBCCCGEkM4mkWEQCwsL3Lp1C3///TdmzJiBqqoqSRz2lVJSUpCWlobs7Gx2NGzy5MnYtGkTli9fDiMjI0RHR+PTTz+FoaEhLl26hPj4eDg4OCAgIACzZ8+GgoICzp8/j9TUVPTp0weLFi3Cl19+CYFAgEOHDsHc3BynT58WW09t2bJlWLJkCbstKyuLc+fO4dGjRzAxMcG8efPwxRdfsI09TExMMHz4cCxbtgx9+vQBwzBtXn+1Zs0a7Ny5E7t378YPP/yA06dPQ1NTk71fT08Pnp6emDt37mtfF5FIhKCgIEyYMOGl+yorK7F161Z88803UFFRwfLly1FeXo6bN28CACIjI5GdnY2cnBxkZmYiOzsbEREREAgECAsLQ3l5+Zv9kt7QvXv3YGtrC3Nzc/z999+vHdkjhBBCCCGkJ+AAAMMwNwCMfdeDNTU14auvvkJgYCDOnDmD4cOHv3OBBGy3xrdtlrJnzx5cv34dwcHBEq7s3TEMg99//x0bNmzAL7/8Ai8vL2mXRAghhBBCSEcL43A47m/dwKMtCgoK+Omnn+Ds7IxJkybhk08+webNm6Guri7J07w3MjIyEBoayq6b9raEQqHYVMSuIiMjA76+vmhsbMStW7fY6+QIIYQQQgh5H3RIt4aZM2ciIyMDzc3NsLKywrFjxzrtWrKe5MGDBzhw4ADU1dXfeuHlgoIC3L17F1VVVbhy5YqEK3w7dXV12Lx5M8aMGQM1NTVkZWVh2rRp+PTTT+Hv74+UlBSx6wEJIYQQQgjpiSQ6TbEtcXFx+OKLL6Curs6+ASfvp8bGRhw5cgTbt2+Hm5sbdu7cCX19fQiFQjx48ACJiYlITExEdHQ0Hj58iCFDhmDkyJEYOXIkRo8eDVNTU2k/BUIIIYQQQiQhjMPhuHd4GAOeT5M7deoUvvvuO+jq6mLjxo0YN25cR52OdDENDQ34/fffsWvXLgwbNgwbNmyAnZ3dax9TXV2N5ORkREdH49atW4iPj4ecnBxGjhwJZ2dnjBo1CiNHjhRba44QQgghhJBuovPCWAuRSIQzZ85g27Zt0NDQwKpVq+Dp6Umd83qo0tJSHDlyBD///DPs7e2xYcOGd2rqUlhYyIazxMREJCUlwdTUVCycDRo0qN3ruRFCCCGEECIlnR/GWohEIly8eBG//vor7t+/Dx8fH/j5+cHMzKyzSiAdKDIyEgcOHEBQUBCmT5+OFStWwMbGRuLnEQgESElJYcNZYmIiCgoKYGdnx4azUaNGQUdHR+LnJoQQQggh5B1IL4y19vDhQ/j7++PYsWOws7ODt7c3PvroI6iqqkqjHPKWnj59irNnz+Lw4cPgcDj47LPPsGDBArH10jpDUVER7ty5w157FhMTAwMDAzacOTs7Y/jw4ZCR6ZDeNYQQQgghhLRH1whjLRoaGnDu3DmcOnUK0dHRGDduHGbOnImPPvoIKioq0iyNvEJ+fj7OnTuHs2fP4uHDh5g2bRq8vb3fuvNjR2jdHKRlimN+fj5sbGzYcObq6gp9fX1pl0oIIYQQQt4fXSuMtVZRUYGLFy/i7NmziImJwbhx4zBp0iSMHz8effr0kXZ57y2RSISkpCQEBwfj8uXLePjwITw9PTFz5ky4u7tDTk6iy9Z1GD6fj5SUFDacxcXFQV5eXqw5iK2tLZSUlKRdKiGEEEII6Zm6bhhrrby8HFeuXMH169cRGhoKPT09TJgwAePHj4erqyuNmnWw4uJiBAcHIygoCKGhoejVqxcmTJiASZMmYcyYMZCXl5d2iRJBzUEIIYQQQkgn6h5hrDWRSIR79+4hKCgIwcHBSExMxJAhQ+Dg4AAnJyc4OjrC0NBQ2mV2WyKRCPfv30dsbCxiYmIQFxcHHo8Hd3d3NgAbGxtLu8xOUVtbi3v37rGNQW7duoX6+nrY2tqya585OztDW1tb2qUSQgghhJDup/uFsRfV1tbizp07iImJQWxsLOLi4qCsrMxOMxsyZAhsbGzoeqA2iEQi5OTkICUlBSkpKYiLi0N8fDwMDAzEwu2gQYMgKysr7XK7hMLCQrGFqePi4mBiYiIWzqg5CCGEEEIIaYfuH8bakpWVhbi4OCQmJiI1NRXJycmQlZXFkCFD2HBmZWUFc3Nz6OnpSbvcDicUCvH06VPk5OQgPT2dfU0yMjLA5XLZ18Xe3h4ODg7o1auXtEvuNpqbm5GZmfna5iCjR48Gl8uVdqmEEEIIIaRr6ZlhrC2FhYVIS0tDcnIyUlNTkZmZidzcXDQ2NqJfv34wNzeHubk5+vXrB1NTUxgZGYHL5YLL5Xb5UY7GxkaUlJSgsLAQRUVFyM3NRU5ODnJzc5Gbm4unT5+Cy+WiX79+GDRoEBu+rK2toa6uLu3yexw+n4/bt2+z157FxsZCQUFB7Nozag5CCCGEEPLee3/C2KtUVVW9FF7y8vJQUFAAHo+H8vJy6OrqwsDAAIaGhuByudDT04OGhobYl7q6OrS1taGhoQFZWVkoKSlBWVmZPY+WltZLjR+amppQW1vLbvP5fAiFQjQ0NIDP54PP56OqqgqVlZWorq5mbystLUVhYSGKi4tRXFyM2tpacLlcGBkZQV9fnw2VLd/NzMygoKDQaa8peVlubq7YwtT37t2DlZUVG85GjhwJa2traZdJCCGEEEI6D4Wxf9Lc3Awej4fi4mIUFRWBx+Ph2bNnbDBqCUktoYnP56O5uRnNzc2orq5mj9MStFprHdhkZGTYxZFVVFSgrq7OBr2WkNdym66uLgwNDWFgYAB9fX2aVtgNvdgcJCoqCo2NjWwwGzlyJFxcXKClpSXtUgkhhBBCSMegMEZIV9HSHKTl2rPk5GS2OUjLFEcrK6suP22WEEIIIYS0C4UxQrqqluYgrdc+a2kO0hLOHBwc3osmNIQQQgghPRCFMUK6k6qqKiQkJLDhLCYmBoqKimLNQezs7KCoqCjtUglpF6FQyE7zrqysBMMwqK6uRnNzM4CXr61t2acFh8MRm86rqqrKXiMrLy8PNTU1dhq4trY2NDU1aXSZEEJIV0FhjJDurnVzkOjoaKSnp8Pa2pqag5BOJxAIUFJSgoKCApSUlCA/Px8lJSUoKSlBRUUFe31t66+GhgZoamqyYenFcKWsrCzWebStRdYrKirYnxsaGlBfX89ut4S3iooK9pxKSkrsOVt/aWlpQV9fHwYGBjAyMmK/c7lcyMvLd9CrRggh5D1GYYyQnqampgZJSUlsOIuMjISMjIzYwtROTk5QUVGRdqmkm6msrER2djb7lZubKxa6ysvLweVy0adPH+jr67Pf9fX1oaOjA01NTWhoaIgFIFVV1U5/HrW1tS+FwqqqKlRUVKCkpATFxcUoKChgv/N4PPTq1UvsOfXt2xf9+/eHhYUFLCws2AZMhBBCyBugMEbI+4Cag5D2qq+vR3p6OrKyspCdnY2srCz256amJjZ8WFhYwNzcHAYGBmKh68UlPHoChmHEQlrLeo6tg6mSkhIsLCzQv39/NqT1798fgwYNElvmhBBCCGmFwhgh76O2moMUFBRg8ODBbDhzdHSErq6utEslHaikpARJSUnsV3JyMvLy8mBpaSk26tMSMLhcrrRL7rJKSkrEgmtLkM3MzISZmSKsD9AAACAASURBVBmGDRuGoUOHYvjw4Rg6dCi9loQQQgAKY4SQFpWVlbhz547Y9WdKSkpizUHs7e1pAfFuqrS0FDExMYiNjWWDl0AgYMNBS1iwtLSk66MkSCAQICMjg33Nk5OTce/ePSgqKmLYsGEYNmwYHBwcMGrUKFozkhBC3j8UxgghbRMKhXjw4AG7MHV0dDQePnyIIUOGiC1M3bdvX2mXStrw6NEjREVF4datW7h16xaKiorg5OQER0dHNoD16dNH2mW+t54+fcqOSLaE5D59+sDZ2RnOzs5wcXGBqamptMskhBDSsSiMEULa78XmIDdv3oSsrKxYc5BRo0bRNTJSkJubi+vXryMqKgpRUVEAABcXF4waNQqurq4YPHgwXRPYhQmFQqSmpooFaBkZGbi6usLFxQUTJ06EmZmZtMskhBAiWRTGCCHv5sXmIElJSTA1NRULZ4MGDeqRjR2kqampCVFRUbh27RquXr2KqqoqTJo0CW5ubnB2dqYRyx6gZdmKiIgIXLt2DTo6OvDw8MCkSZPg7OxM00kJIaT7ozBGCJEsgUCAlJQU9tqzluYgdnZ27LVnTk5OdH3MWygsLMS1a9cQGBiIsLAwWFlZsW/Ohw8fToG3B2MYBnfv3kVgYCACAwORmZkJd3d3TJo0CZMnT4aBgYG0SySEEPLmKIwRQjpecXExEhIS2HB269Yt6OjoiC1MTc1B2lZeXo6zZ8/i5MmTuH//PsaPHw8PDw9MmDCBAu177NmzZ7h+/ToCAwMRHBwMGxsbzJs3D15eXm0ujE0IIaRLojBGCOl87WkOMnr06Pe2gUFDQwNCQkLw559/IigoCK6urvD29oanpycFVvISoVCI8PBwHDt2DJcuXYKdnR0WLFiA6dOnQ01NTdrlEUIIeTUKY4SQrqG6uhrJycnstWfx8fGQk5MTu/Zs5MiRPbY5CMMwCA8Px9GjR3H16lU4Ojpi3rx58PT0pDfUpN2qq6tx8eJFnDx5EvHx8ZgyZQp8fHwwZswYaZdGCOkAfD4fz549Q01NDWpra1FbW4uKigrU1tayt1VUVLD7CoVCsce23n6RpqamWOOnlm11dXWoqqpCVVUVWlpaUFNTY7e1tbWhpqYGPT09mjrfPhTGCCFdV2FhodjC1C3NQVqHs+7eHKS2thZ//vkn9u/fD1lZWfj5+WHWrFnQ09OTdmmkm+PxeDh9+jR+//13MAyD5cuXY/78+VBRUZF2aYSQ12hoaEBeXh6ePHmC/Px8FBUVobS0FM+ePcOzZ89QXFzMbispKaFXr17Q0NBgA5GmpiYbmNTU1KCpqQk5OTmoq6uLneefpjTX1NRAIBCI1VVfX8+GvpqaGlRWVrLb1dXVqKysRHV1NcrLy6GjowM9PT3o6upCX18fXC4Xurq60NPTg7GxMUxMTGBiYvK+T62mMEYI6T7a0xxk1KhR0NHRkXap/yg3Nxf+/v44cuQIPvjgA3z55Zdwd3fv1sGSdF2JiYn46aefEBgYiE8++QQrV66kjpuESIlIJEJeXh4yMzPx8OFD5OXlseHryZMnqKqqYoNKnz59YGhoyIYaPT09GBgYQFdXF7q6ulBUVJT202mTSCTCs2fP2NBYUlICHo+HZ8+egcfjIT8/n33OIpEIJiYmMDMzY593v379MHDgQAwYMKDLPkcJoTDWXvX19SgtLQWfz0dNTQ1qampQUVHB/lxbW4vKyko0NTWhtraWfVzLpwgt6urqoKCgADk5Ofa2F4eBtbW12U8wWoZ/W4aAW4Z/NTQ0oKenJ3YcQt5HRUVFuHPnDnvtWUxMDAwMDNhw5uzsjGHDhkFWVvatji8QCFBaWgpDQ0OJ1BsdHY3t27cjISEBn376KT7//HMYGxtL5NiE/JO8vDz89ttvOHr0KBwdHbFu3To4ODhIuyxCeqSmpiakp6cjMzMTGRkZePDgARvA9PX12bDROoSYmJi8d91R+Xw+njx5gsePH7OBNDs7Gw8ePEBubi4MDQ1haWkJKysrDBw4EJaWlrCxsYGmpqa0S5cECmPPnj1DXl4eHj9+jIKCApSWlqK4uBg8Hg+lpaXg8XgoKSmBSCSCnp4eNDQ02HCkpaUFdXV1drvlvtZrv6iqqopdcK+iogKBQCA27FtbW4umpiZ2u66uDvX19aiqqhILfy3DvzU1NaiqqkJpaSm0tbWhp6cHPT09dgi45VMTY2NjmJqaom/fvj32OhtCXtS6OUjLFMf8/HzY2Niw4czV1RX6+vrtOl5CQgLc3Nywbds2rFix4q1D3d27d/HNN98gMzMTX3/9NebNmwclJaW3OhYh76q+vh7Hjx/H999/j8GDB2Pr1q0YNmyYtMsipNtqampCSkoKEhMTcffuXSQmJiIjIwP9+vWDlZWVWJgYOHAgTRdup+bmZjx69EgszN6/fx/p6ekwMDBgm36NGDECI0aMgJaWlrRLflM9P4wJhULk5ubi/v37yMrKwuPHj5GXl4dHjx4hLy8PioqKMDU1hampKYyNjdkg0xJq9PX1oa+vD1VVVWk/lTa1DPeWlpayQ8ClpaUoKirC06dP2eeqqanJPk8zMzP07dsXAwcOxKBBg967T2DI+4fP5yMlJYUNZ3FxcZCXlxdrDmJra9tmONq/fz9Wr14NWVlZGBkZ4fjx47C3t2/3uTMyMrBp0yZERkZi1apVWLlyZU+fckG6EYFAgKNHj+Lbb7/F8OHD8d1332HIkCHSLouQLq+oqAiRkZGIjIxEXFwcHjx4gP79+7PBYOTIkRg6dCh9GN5BhEIhMjMzxcJvUlIS9PX1YW9vDxcXF7i6usLKyqqrT//vOWGs5dPw9PR0ZGRk4P79+3jw4AGysrJgaGiIQYMGYeDAgWwYMTMzg6mp6UsXM/ZUJSUlbBDNy8tDbm4uMjMzkZ6eDoFAACsrKwwaNAiWlpawtraGjY0NjIyMpF02IR2mvc1Bpk2bhkuXLgEAOBwOVFRUMHnyZPz222+vXefr8ePH2LhxI4KDg7FmzRp8/vnn9J8y6bLq6urwyy+/YPfu3Zg0aRK2bt1K02cJaSUvLw+RkZG4efMmoqKiUFZWBmdnZ4wePRpOTk4YOnQozXaQMpFIhIcPHyI+Ph43b95EZGQk+Hw+XFxcMHr0aLi6umLIkCFilwZ1Ad0zjDEMg+zsbCQkJODOnTtISEhAcnIyjIyMMHjwYLFgYWlpSX85/kF5eTnu37+PjIwMZGRkID09HSkpKeBwOLC1tYWtrS3s7Oxga2tLHd5Ij1VbW4vExETEx8cjNjYW8fHxEIlEaGxsZNsCt1BUVIS8vDx2794NPz8/sU/dGhsbsXv3buzduxfLly/HqlWr3psPfUj3x+fzsXv3bvz222/46quvsGrVKrGp94S8L5qbmxEVFYWrV6/i8uXLqK6uhqurK/vG3trauquPuBAABQUF7AhmZGQkSktLMWnSJHh4eGDChAld4bqz7hHGmpqacPv2bYSHhyMqKgoJCQnQ0dERCwkjR46kNzwSlp+fzwbeli91dXU4ODhg9OjRcHNzg5WVlbTLJKTDJCcn44MPPkBjY2Ob96uqqmLAgAH4888/YW1tjaioKCxevBiDBg3C3r1739tFq9sjLi4Ou3btgpmZGerq6lBVVYXvvvuuQzv8lZWV4ccff4S7uzvc3d077Dw9QW5uLr788kvk5ubi8OHD1OSDvBfKy8sRGBiIK1euICQkBBYWFpgyZQo8PDwwfPhwaZdHJCA/Px9Xr17FlStXEBkZCVtbW3h4eGDq1KmwsLCQRkldM4wJBALcvn0bERERiIiIwO3bt2FpaYkxY8Zg9OjRsLe3f+30INJxcnJyEBsbi/DwcERERKCurg5ubm7s18CBA6VdIiESc/XqVXzyySeoqqp65T4cDgcyMjIYMWIE8vPzceDAAUydOrUTq+x+mpqaYGJigtDQUAwePBhNTU2YPn061q5dCxcXFwDPG6fY2dlJ7JyVlZW4desW5s6diz///BPTpk2T2LF7svPnz2PZsmXw9vbGli1b6HpH0uPU19fj8uXLOHHiBCIjI+Hu7g4PDw94eHiAy+VKuzzSgerr63Hjxg1cuXIFly9fhqGhIT755BPMmTOnM/spdJ0wVllZicDAQAQEBCAkJAT9+vVj3+C7urrSqFcX9eTJE0RERCA8PBzh4eGQkZHB1KlTMXXqVLi6ulLrfdKt/ec//8GOHTsgEonYqYkMw6CxsREKCgrQ19eHnp4esrOzYWZmht27d2PMmDHSLrvLy8nJgYWFBcLDw+Hm5gYAyMrKwr179zBr1izEx8dj9erViIqKkvi5zczMsHfvXgpjb6C0tBRffPEFsrKycPbsWfTv31/aJRHyToRCIcLDw3HixAkEBATggw8+wLx58/Dxxx9DTU1N2uURKRCJRAgPD8fx48cREBAAe3t7fPLJJ53xZ0K6YezJkycICAhAQEAAEhISMGbMGEydOhVTpkyha5O6qbS0NFy6dAkBAQHIycnBxIkT4enpiUmTJtE/cKTbWbVqFTIyMmBpaQkLC4uXmv+cPHkSq1atwvbt27Fo0SJpl9ttCAQCDB48GMXFxTh06BBmzpzJ3lddXY1p06YhKysLS5cuha+vL5SVleHv74/KykokJiZi165dMDExwS+//ILw8HB4eXlh3759EAqF8Pf3h5OT0yvPTWHs7fn7+2PDhg345Zdf4OXlJe1yCHljfD4fhw8fxv79+6Gjo4P58+dj9uzZ1FWaiGkZLT1+/DhiYmKwYMECLF++HObm5h1xujAOh/N83jzDMDeYTsDn85mjR48yo0ePZvT09BhfX18mICCAqaur64zTk05UWFjIHDx4kJk8eTKjpaXFLFiwgAkJCWGEQqG0SyPknYhEImb9+vVM//79mZSUFGmX0y3l5eUxDg4ODADmo48+YgoLC9n7Dh48yDg6OrLb3t7eDI/HYxiGYb7++mtm8ODBDMMwzN9//80oKSkxDx8+ZEQiEbNs2TLG2NiYaWxsfOV5TU1NmQsXLnTQs+r57t69y5ibmzObNm1iRCKRtMshpF1ycnKYtWvXMlwul5k5cyYTHR0t7ZJIN1FUVMRs2rSJ4XK5zIcffshcunRJ0v/23QCADu/vKBKJEBoaCm9vb5iamiIgIACrVq1Cfn4+Dh06hKlTp1LL5x6od+/e8PPzw9WrV5GVlQU7OzusX78eZmZm+Prrr5GZmSntEgl5Y42NjZg7dy6ioqIQGxsLGxsbaZfULZmYmCA6Oho//fQTbty4gZEjRyInJ4e9v6VLWWlpKSIiInDhwgX4+/tDTU0NTk5OaGpqgpaWFjQ0NNC/f39wOBxs2bIFT58+RVZWlrSeVo83fPhwxMbGIjg4GN7e3hAIBNIuifRQRUVFYBjmnY6RmZmJWbNmwdHREbKysrh79y7OnDnz2tFzQlozMDDA5s2b8ejRI8ycORPr1q2Dra0trl27JtHzdFgYq6urw2+//QZLS0usX78e9vb2yMrKwoULF+Dp6QkFBYWOOjXpYnR1dbF8+XIkJCTg2rVrEAgEGDt2LCZMmICQkBBpl0dIuzQ0NGD69OkQCoUIDQ2lRkJv6dGjRwAAGRkZrFixArGxsaiqqsLOnTvZfVrCWH5+PgQCAfz8/ODn54d169bh4MGDbf7/oa2tDXl5eWo33cG4XC7CwsJQU1ODmTNnoqmpSdolkR7o66+/hpGREX744QeUlJS80WMLCwuxZMkSuLq6wt7eHo8fP8Z3331H66eSt6aiogI/Pz+kpaVh06ZN+OqrrzBmzBjEx8dL5PgSD2OlpaXYsWMHBgwYgMDAQPz6669ISEjAsmXL6M0LgbW1NXbu3InHjx9j8eLF+PrrrzF06FD4+/ujoaFB2uUR0qbGxkZ4enpCS0sLp06doq5y7+DSpUuIjY1lt4cOHQo7Ozv2TT2Hw4FIJAIAmJqasqNjLdLT0/Hw4cOXjvv06VP06tWLGkx0AiUlJZw5cwYKCgqYMWMGjZARiauoqEBRURG2bt0KU1NTjB8/HkFBQey/DW2pra3F+vXrMXToUOjo6CAzMxOrV6+m2VdEYjgcDqZOnYrk5GR4e3tj1qxZ8PLyQm5u7jsdV2Lt7srLy7F161YcO3YMs2fPRkREhLR69pNuQF5eHjNnzoSXlxdCQkLw448/Ytu2bdi0aRN8fHwgKysr7RIJAfB8oXlfX19oamri2LFj9GfzHfXr1w/e3t44e/Yshg0bhqysLGRkZGDHjh0AAENDQ2RnZyM+Ph6amprw8/PDjBkzsGbNGigrKyM/Px87d+5Efn4+KisrkZKSgsGDB+Pbb7/Frl27XrlIsUgkQk1NDX3oIyHy8vI4efIkvLy88Nlnn+Hw4cNt7tfQ0ID6+nowDIPKykoAQE1NDQQCAQQCAWpqagAAVVVVEIlEYrcBz99gtx59a70Ie1NTE2pra9ntluO2aDnmi148R2svHuOfCIVC8Pn8du//IgUFBaiqqrZ7f3l5+Vc2xFJVVX1p1FhTUxMyMv//c3cZGZmXFrp98Zja2toAnr/x1NLSeu3PrY/X+md1dXXIycm1WVN7VFdXA3jeTAEAQkJCEB8fDxkZGfj6+mL58uViazlGR0fDx8cHTk5OSE5OhqGh4Rufs7vLycnBiRMnICMjAxcXF1RVVXXoUivl5eU4duwYampq4Onp+V5N25eVlcWiRYswd+5c7Nu3Dw4ODvj222+xZMmSt5qd8c7dFBsbG7F//37s3LkTs2bNwsaNG6kbInkrd+7cwVdffYWysjLs2rULEyZMkHZJhGDz5s0ICQnBjRs3oKSkJO1yur28vDzcvn0bpaWlKCgoAADMnz+fXUS+ubkZP/zwA/r06YNFixZBJBLh0KFDSE5Ohq2tLRYuXAgZGRmEhYWx/xE+fPgQzs7Or1xaoLa2FpcuXcKTJ0+gpaWFMWPGYMCAAZ32nHuylvUmy8vLIRAI2DfRLUGo5c24rKwsNDQ0APz/N+qtg0hLaJCTkxNbzubFN/MtQQF4OcioqamJhfEXg0iLNw00r9P6eb2NFwPlP3nTIPliIBWJRC+tnfhiDa0Db2VlJXvtVuufWx+Xz+dDKBSK/VxfX4+GhgY0Njairq4OKioqUFRUhJKSEpSVlaGoqAgVFRX2d9HyOrYEusjISDx48KDN59kyM8HR0RHLli3D7du38eeff+LXX399bzulPnr0CB9++CGuXr0KQ0ND7N27FydOnBC7Pr+2tvaNgv/rFBcXY9GiRbC1tcWdO3dw48YN3Lx5E46OjhI5fneTm5uLRYsWQVFREYcPH4axsXF7H/rure3Pnz+Pr776CkOGDGGnJhLyri5fvow1a9bA1NQUP/30Ey0mTaQmLCwM3t7euHv3Li0A2sW0hLE3vZ6ESF5RURGGDx+O3377DW5ubmIjJ4QA/z/wNTc3o7q6mh1RbD1i2hICW64hfV0zHjk5OQiFQsjIyMDS0hKhoaHvdYv6Xbt24cKFC4iJiWFv8/Pzg7+/PwDg5s2bSE5OxooVKyRyvv3792PhwoXsBydubm7o27cvjh49KpHjd0dCoRC7du3Cf//7Xxw6dAhTpkxpz8PevrV9ZWUls2DBAsbKyoqJjIyUZIvHDlNcXMysXLmSaW5ubvdjhEIhc/78+VfeX1RUxPj7+zM3bnTKygAvqaioYJKTkxmGYZi6ujrmxIkTjL+/P3P69GmJtx0OCwvr1FbGAoGA+fnnnxkul8vs37+f2iiTTldeXs706dOHCQ0NlXYppA3nz59n1NXVabmMLuLatWuMqakpU1VVJe1SSA9gYWHBABD7UlZWZlRUVBh9fX3G09OT0dHRYX777Tdpl9olHD58mOFwOMzu3bvZ2x4+fMg0NzczCQkJTK9evRgPDw/m8OHDDMM8f491/PhxZsuWLUx8fDzDMM+XbYmOjmZCQkKYkJAQ5l//+hcTEBDQ5vmKiorEtlevXs0sXry4g55d93L79m3G2NiY2bVrV3t2f7vW9rGxsbC1tYWysjISEhLg4uLypoeQiqamJpSVlbFD6QBeOdQPPG+JunjxYixYsOCV+zAMg59//hn379+XaK3t8fTpU+zduxfW1tZobm7GRx99BGdnZ/zf//0f8vPz8Z///Eei5zM3N8emTZveudVse8nJyWHZsmWIj4/H6dOnMWHCBHZKEyGdYdOmTfD09IS7u7u0SyEvqKiowOPHj/HFF1/g0KFDdB1YFzBx4kSMGzcO3377rbRLIT1Ay9/plmmjw4YNw7Zt25Camoo//vgDsbGxOHfuHD777DMpV9o1eHt74+OPP8bq1asxbtw4ZGdno3///pCVlYW1tTWsrKzg7OwMLy8vMAyDFStWYOzYsZg/fz4mTpyI69evIzMzE1988QU2btyIsrIyGBsbY86cOThx4sRL53txFPL+/fuYM2dOZz3dLs3Ozg5xcXH4448/8M0337T/gUw7RsZEIhGzbds2xtDQkAkMDHy32NgFZGVlMatXr37tPpGRkYyqqupr95k8eTLz888/S7K0f9TQ0MB8+OGHTG1tLcMwDJOWlsYYGxuzo0cpKSmMnZ2dxM97/vx55rvvvpP4cf+JQCBgtmzZwvTu3Zu5efNmp5+fvH/S09MZAwMDpqysTNqlENJt8Hg8hsvlMg8ePJB2KaSbs7S0ZCZPnswcP36cKS8vZ2+PiYlhuFwuExMTI8XquiaRSMQcPnyY0dbWZlRVVZlTp06x940ZM4bZt28fwzAMc+HCBcbFxYXZvn07s337dsbc3JyZNWsWwzAMs3jxYmb58uXs49auXcs4Ozu/9rx3795lvvzyyw54Rt1baWkpM3ToUGb79u2v2+0G0M5uis3NzVi8eDEyMjKQmJjY6fNynz59ilOnToHL5WLOnDn466+/UFJSAhcXFzg5OSEqKoodyeLz+Th79iwUFRUhFArh7e0NDocDPp+PCxcu4OOPP0ZlZSUmTZoEHR0d7Nq1C1999VWb523rwt9XCQgIQHx8PD7++GPY2dmxtwcFBSE7OxtycnKYO3cuNDQ0kJqaisDAQHh4eKBv3744ffo0SktL2TqioqKgpKSE7OxscDgczJs3T+xc/v7+sLGxgYqKCgDA2NgYfD4f27Ztw4YNG/DXX39h4cKFAJ5fcHvx4kWMGTMG586dQ1lZGfz8/GBmZgaBQICgoCAMGzYM9+7dQ1JSEhYsWAAdHR3873//A8Mw8PPzY9vCTps2DV9//TV8fX2hr6/f/l/gO5KTk8PGjRvh7OyMWbNmYc+ePS+9JoRI0vbt27Fq1Sro6OhIuxRCug09PT0sX74cu3btwqFDh6RdDunG0tLSXupcm5+fjxkzZuDYsWPvbaOI1+FwOPj0008xfvx4zJ49GwsWLICdnR369evH3g8At2/fhru7O9auXQsA7PeWfVq/9x05ciTOnz//ynPyeDz8/fff2LNnT0c8pW5NV1cXgYGBcHJygqWlJTw9PV+57z+mjebmZsyfP59d60UaF0gaGxsjLCwMqampUFJSwtChQ7F+/XpYW1sDeP5mvcWCBQugpqaG+fPn49ixY7h06RKamppw4cIF+Pj4oKamBgYGBhg9ejSsra2xePHid67vypUrAJ63ZB43bhzbhvfLL79EQUEBli5dCg0NDQwdOhQ8Hg82NjY4ceIEEhMToaqqikGDBmHdunUQCoWIi4uDl5cXdu3ahUePHiEuLu6l8/35558YNWoUu62hoYGzZ89ix44dGDFiBKytrbF06VIAwIULF7Bo0SL88ssvsLKyQlZWFpycnFBdXY3g4GB8/PHH2L59O+Tl5VFcXIxp06bhwIEDsLGxwYULF9h208Dzv6TDhw/HyZMn3/k1extjx45FeHg41q5di2PHjkmlBtLzFRQUIDAwEEuWLJF2KYR0O1988QUuXrwIHo8n7VJIN/ZiEGMYBj4+PlixYgV1Wm7Dtm3b2J/79OmDo0ePorm5GSkpKeztLWFMTU0N0dHRYo9/1TpZfD7/lU3UamtrsXfvXmzcuJENcLQIvDhDQ0OcOXMGn332GQoLC1+53z+GseXLl6Oqqgrnz5+X6sJ5y5Ytw6VLl8AwDIYNGwZdXV02rQcHB7MjJXPmzIGDgwOam5uhpKSEtLQ0KCgoiCVSBQUFtsVq6za5b8vd3R2enp7w8/NDbW0tsrOzkZaWhkOHDmHRokUAgLlz50JfXx8//PADAIi1yG695oeTkxNsbGzg4OCAb775Bvv27RM7F8MwSEpKeikUDx48GPPmzUNpaSn27t2L0tJSAGCvefPx8cHkyZNx/PhxiEQiBAQEwMPDAwYGBpg2bRomTpwIX19fpKamYs2aNRgzZgxmzpyJtLQ0sfMYGRkhISHhnV+zt2VlZYXQ0FCsX78e165dk1odpOc6d+4cPv7445fW4ukpsrOzxd4op6SkvPb62Z6koKAAeXl57HZOTs5bdWN89uwZ2wGOiNPR0cHkyZPx999/S7sU0oP89ddfqKmpwZo1a6RdSpd0+/ZtXL58md2uqqqCqqoqO1NLTU0NZWVlqKurw+TJk3Hjxg3s27cPDQ0NSElJwblz59jHtl7a4Pz58/jyyy9fOl9zczNWrlyJ8ePHIzU1Fbdv38avv/6KjIyMDnyW3ZO9vT0WL16M9evXv3Kf14axgwcPIiYmBmfOnGHXdZCWSZMmoampCTdv3sTVq1cxYcIEHDlyhF1MsmXK3tSpU3H9+nUEBARAQUEBzc3Nrzzm2yzM9joKCgqQl5dHfX09kpKSoK2tLXaOUaNGiX1K8SqKioqvfL1bFspsvUZKfX093N3d8cMPPyAxMRFKSkovLfTXUoeioiIGDRrEvhlrXV+vXr3EHqOsrPzSeiSqqqpSf+M2cOBA/P333/Dx8UF2drZUayE9z8WLFzF9+nRpl9EhTp48CSsrKyQlJaG+vh779u3D0KFDX/uJXU8RHByMwYMHsx/iw+r6dwAAIABJREFUnDp1CpaWlrh3794bHefq1aswMjJCcnJyR5TZI3h5eeHChQvSLoN0YSKRqN2Nd0QiETZu3Ijdu3e/0eUj75MhQ4bg/PnzWLduHb7++mts2rQJFy5cQJ8+fQAAM2fOxLFjx3D48GEMHToUR44cwY8//ghDQ0McOnQIK1euZI+VlZWF77//HitXrsT06dPx4YcfvnS+H3/8EWFhYfD19cWsWbMwd+5cXLlyBUOHDu2059ydrF27FiEhIa9cO++V14zl5ORgw4YNuHXrltgCjNIiKyuL//u//4O/vz/09PTg7+8PY2NjbN26FZ988gm735QpU7B69WpMnjwZAQEBrz2mpMNYa/r6+igpKRFbZE9JSemdp3kqKChAR0dHLBAlJCRAQUGBDVPnz58Hl8tFeXl5m4tRvmrYuT2vR1lZGUxMTN7hGUiGg4MDNmzYgIULFyIyMvKlKQ2EtNbY2NiuD5SEQiESExPh6uraCVV1vnnz5rGfLCsrK+Ozzz5r81NPSUhJSUFjY6PYNbRv6uHDh+DxeHB2dn7nesaPH4/Bgwez23Pnzn2rT9k9PDygp6f3zvX0ZG5ubliwYAFEIhG9eSZtqqurQ+/evTF58mT4+vrC3d39lf+Ph4eHQ1NTUyL/DvRUracptmXBggVi3cEXLlzI9hZ4kb29/T925F67dq3YtWbk9dTU1LBo0SIcPnwYu3bteun+V/4ruWbNGqxZs6ZLLeTs6+uLCxcuYNSoUVBWVob3/2PvvqOiurq/gX+p0qQoTZAiIFIMCioWEEEURYkxKhofoxKjkkiWLcYSIw+KGhR7iV0DlkexRgU7HRUliIUuTRCk987Mfv/gN/dlpNgF9XzWmgUzc++dc2eGy933nLP3jBmIiIjg5o4VFRUhKCgIMjIyqKqqQkpKCurq6sDj8biU9oIrMYIu25aq0Qvw+fxXpnIXVJgHGk/kGhoaUFNTAxsbGxgYGODYsWPcsv/++y/mzJkDoHGeV0JCAogI//77LwBww174fD5X2b4ltra2QsUQdXV18eLFC1RWVgJoDNi0tbWFhmAKup2fPn2K2tpajB49utlrlZeXg4i4Mb88Hq9ZO7KysmBpadnme/KxuLm5QVRUVOg9ZpiWLFiwAGZmZtixYwdycnJaXS4+Ph5aWlrcBZRPARHh6dOnzfarpKQEUVFRKCwsFHq86cnx65wo19XVIS0trdkog5qaGlRXVyM7O7vZFe7s7GxMnDhR6LgENJYTaVqiorq6GsXFxSguLkZtbS33O4/HQ35+PiZMmIDMzEyhbbwsMzMT6enpzR5/8eJFs6GEL+9vW/svKE5bVlaG2NhYobIogvXKysqQlpbW4rppaWmor68Xeryurg4VFRWoqqpqcb3KykpkZmYKPUZEiIuLQ3Z2dpsjPToSeXl5qKmptVm0l2Fqampw+vRpTJo0CV26dMGcOXNw586dZudd/v7+cHZ2bqdWflkaGhqEjnXM+zN58mT4+/u3+FyL/4kePXqE+/fv45dffvmgDXtT3bp1w+LFizFx4kQAjdXFf/75Z+55wR+zi4sLNm7ciB9//BG3bt1CSEgIDh06BD09Pfj6+qK6uhrjxo1DZGQkPDw8WrxiHhcXh1OnTkFdXR1HjhxBUVFRs2Xu37+P4uJiREVFITMzEz4+PtDS0sKFCxcgLi6Oy5cvIyAgAJs2bcKOHTswbdo02NraAgCWL1+OU6dOYeTIkVBVVcXw4cNx/fp13LhxA0VFRQgNDUVsbGyL78P8+fMRFBTE3dfW1sa+ffuwdOlSHDlyBN7e3jh37pxQT9eZM2fg6emJP//8E5cvX4aYmBgCAgIgIyOD69evIz8/H2fPnkWPHj3g4+ODnJwchISEoLCwkKvoXl1djfj4eEyZMuXNP7wPQEREBBs2bICnp+dHq3/GfJp4PB4eP36MFStWQE9PDxYWFtizZw8KCgqElsvMzESPHj3aqZVvLi4uDitWrMDz58/h4uICd3d3AMCVK1ewaNEidO7cGTNnzhSaS/Amtm7dCm9vb0RFRWHo0KFc8p5Dhw5BU1MTO3fuxJAhQ5rVUomPj0d2djZCQ0Nx7949EBE2bdqEU6dOwd3dHWPGjEFdXR2Kioowffp0mJqaoqqqCr/88guOHTuG+vp6bht37tzhjkFNZWdn49dff8XTp0/x3//+FzNmzADQ2Hvv7u6Oq1evwsnJiZun+yZu3LgBTU1N/Pbbb1i4cCGcnJxgZWUlFBReuXIFS5cuxTfffCP0f+jvv/+Gu7s7YmJiYG9vj7/++gtA4zBJDQ0NbvjP6NGjha4s79ixAydOnICXlxfs7OxQVVUFAPjhhx9QV1eHwMBArFy58o33pb3o6uo2CywZpikREREQEXfR4/Dhwxg1ahRUVFQwb948REdHA2icD8WyJ354iYmJSEtLQ3JyMsLDw9u7OZ+dr776CllZWSgrK2v2nAjQWGcMwHDBg4sWLYKioiL++9//frxWfsY+xFCNRYsWYeHChdDR0WlzuYaGBkhISCAuLg7Gxsbv9Jr79u1D165dMWnSpHfazvtmYWGBLVu2cIEuw7zM1dUV+/fvF3pMVlYWDQ0NMDQ0xKxZszBt2jTcuHEDAQEBn0Rva319PWxtbXHt2jXIycnh3r17OHjwIPbv3w8PDw+oqKjAzc0NXl5eiIuL4zKQamtr4+DBg3BwcOCOD4mJic1GQQQGBuK3337jeu6jo6MxePBgxMTEQF9fHzIyMvjf//6HcePGNZvHCgBKSkq4ePEihg4dCj8/P2RkZGD27Nmor6+Hrq4udu7ciR9//BGFhYUwNTXFH3/8gZKSEqHATktLC/v374ejo2Oz/R8zZgz++usv6Orq4tmzZ5g/fz7Onz+P2bNnY968edDT00NoaCgmTJiAtLQ0aGtrY9iwYZg6dSpXKFZHRwf79u3jRgo01bNnTyxZsgSurq4oKyuDiYkJfvvtNyxYsADa2tpYs2YNXFxcEBISgvHjx6O4uBgxMTGYOHEikpKSICYmhvT0dPTs2RPBwcGwsrJCz5494ebmhoULF+LSpUuYN28eMjMzceXKFdy9excLFy4EEcHAwADu7u6YPXs29PX1ERcXh65du+LatWufTCa5KVOmQF1dHRoaGu3dFKYDqqurg6enZ7PeYwFxcXFISEhAVVUV5eXlOH/+/Gc7fJz5chgaGsLf3x89e/YUPBQoIiJi3+KcsatXr8LPz+/jte4z9yHGzG/cuBFbtmzBjz/+CGVl5VaXEwxraWvY4+sIDw+HvLx8hwvEAGDChAm4evUqC8Y+sMrKylbT1rY13BdonB8gGM7bkqbZm14mGA7XmpKSklZ7Ruvq6lBZWdnipFlBL8fjx4+xatUqLF++HHp6elBUVERFRUWz4KKjefToEerq6rh2WlpackOIPTw8UF5ejrNnzyI2NpbrZXkTFy5cELqAY2FhAU1NTVy/fh0LFiyAjIwM9PX120w4JOidF8xjPX36NABg27Zt+OqrrwA0Jg7avXs3vvvuuxYTibQ0l7WoqAj37t2Drq4ugMYA88KFCwAay3kMGDCACyL37NkjVP7kdUlKSkJRURFA47C7MWPGICYmhnteMP+3e/fuKCkpQW1tLS5dugQDAwNu7ouuri769euHgIAAWFlZQUJCgjted+vWjfvenzt3DqKiotz74+XlBVNTU8jJyWHw4MHo06cPNmzYIDQ/+lMgGHrKMC97VQp0Pp8PMTExVFZWgs/ntzlUmWE+dc3+Q1VUVCArK4ubh8V0TBISEli6dOkrs6D5+PhAT08PJ06cgJub21tfpdTX1++wk2ctLS2xdu1a3Lx5s9lzFRUVrV554/F4LXYXC7QVfBBRm6mtq6ur28wU1VYAUVtb2+bJc2lpaavBdX19fZvZLsvLy1uddyKYI9MaWVlZSEpKtvicqKhom6ngpaWlhco5vKytEhNSUlJtltVQUFBo9YKHpKQk1wPWFhEREYiIiEBRURE8Hq9dy3i8rsLCQmRnZ7fY837t2jX8/fffOHLkCNLS0nDnzp033n59fX2z74Ompmarf08tEQRSZWVlsLa2xty5c1tcrra2FsbGxli1ahX27t3b4jaaKioqQklJCcrLy4USTPF4PFRUVMDe3r7plcf3olOnTi0mRGqqpb+h13nPSktLYW5u3uL7c+7cOWzevBmurq64e/cudu7c+eaNbwfFxcWYM2dOi5nYGKaiogK7du0SekxERASdO3cGj8fDmDFjMHfuXNjb28Pa2rpDJJJjmHfB5/ORm5sLVVXVZs81C8by8vKgpqbGMiB9AkRERKCpqdnmMq6uru+leG23bt3eeRsfioaGBjIzM4UKVAvIyclBQkKixfXExMTaPLmSkZFp84p/WwGEhoZGm8GHoqJiq9krO3XqxJVqaElbwYeEhESbPTqdO3dutZdAXFz8s/2Ht2jRombzjmRkZMDj8WBoaIhffvkFU6dORVpaGqZNm/ZJZOc0MzNDYWEh9uzZwxV5P3XqFCZNmoRFixZh9erVkJKSQl1d3VvNqRw+fDhcXV1RU1PDfZezs7MxfPjwV6zZSFxcnAtCBgwYgN27d2PGjBmQl5dHeXk5fH194ebmhszMTCQkJODSpUv46quvMHnyZO41mm6jKV1dXSgpKcHDwwObN28G0DjJf+jQobCwsICXlxcOHjwIERERPHjwAHl5ee88vO/ff//Fxo0bATRejBG8p01/2tnZYcOGDSgoKOB6wLKysloNQgUsLS2xa9cuuLq6okuXLqiursaBAwcwbdo0REZG4rfffoODgwP69++PLVu2tHpM60iePXv2yv9PDAM0/p9uaGjA2LFjuQC+6TG4f//+uHv3boe9IMwwryMuLg7q6uqtX7gmolv0f1JTU0lPT48Y5lPx+PFj+uqrr9q7GUwH9uuvvxIAEhcXJ2lpaTIwMKDNmzdTTk6O0HL19fUkJydHlZWV7dTSN7Njxw4SFxenwYMHk4ODA927d4+IiOzt7cnQ0JCWLFlCCxYsIC0tLTp37hylpaWRrKwsbd++nXg8HkVGRhIAunDhQrNt8/l8mjlzJs2dO5fKysro6NGj5O7uTkRE8fHxJCYmRgcPHiQej9di22xsbOjbb7+lY8eOUUFBAZmYmJCWlhb95z//ocmTJ1NJSQmVlZXR2LFjqaSkhIiIFi1aRFpaWpSenk5ERI6OjjRmzBg6cuRIs+2fP3+epKWlqU+fPjRq1Ci6dOkSERGFhYVR586dqX///vTdd9/RihUriIgoNzeXevToQYsXL6b6+npKS0sjOTk52rZtW4v7YGJiQuPGjaOoqCj6888/acmSJURElJWVReLi4uTp6Ul8Pp9OnDhBACgiIoKIiJYsWUKTJ0+m4uJi8vf3p3nz5hERUUFBAXXu3JnWrVtHfD6fdu3aRaKiopSSkkJlZWVkbm5OGhoaNHXqVJo4cSLl5eVRfn4+DRw4kLKzsykuLo6cnZ1f74vRzsrLy6lz586tfjcYpry8nCQlJcnBwYHOnDlD1dXVrS575coVsrS0/Iite/9u3rxJDg4OdPDgQSIi8vPzIysrK7p69Wo7t+z9unv3Lk2ZMoX+97//vdF6jx8/JnNzc6qtrf1ALWt/7u7utHDhwpcfvgW0kMCjoqICGhoaKCkpYb1jzCfhxo0b2LBhQ4vDFBkGAFasWIFDhw5h1qxZcHFxgZGRUavL2tjY4I8//oCDg8NHbOHbS0lJQXJyMiwtLdGlSxcAjUNsIyIi0L9/f8jLy+P+/fvo378/njx5wg1x1dbWxrNnz7jtGBsbt9gjGxkZicTERPTp04cr6BkdHc31COnq6jYrGA8Aubm5ePToEYYNGwZJSUlUVFQgLCwMEhISsLW1hbi4ODIyMlBQUABtbW2oqKhw25WSkoKpqSkKCgoQHR0NGxubFnuas7Oz8eDBA1hYWAj13mdnZ+Pu3bvo0aMHzM3NAQCxsbHc0OHu3btzQzwBQE9Pr1lPt6mpKVasWAElJSXo6OhwNcoSEhK4+Ss9e/bk0rdLSkpy8+BiYmLw6NEjGBkZcfP4nj59ys2r7NGjB5faXkZGBsbGxqiurkZoaChERERga2sLSUlJ1NfXIzU1FampqZCTk4O1tfUHrY/5vvj7+2PLli24detWezeF6aD4fD7Ky8vbHN4uwOPxoK+vj5MnT2LQoEEfoXUfxqBBgzB9+nRuJEO3bt1w8OBBjB07tp1b9n5ZWlpi3rx5cHFxaXO5pKQkLnFUWVkZzp8/32rts09dVVUVDA0Nce3atZengQWKiIjYt5hN0cjICGfOnBEqkMkwHdW6detQVlbW4jBFhgEa51d16dLltU5kt27dioSEBOzbt+8jtIzpqExNTeHu7t5hSnl8SlxcXDBgwADupJNh3tXff/+NQ4cOcRcsPkXDhw/HxIkTub8LPT097Ny587MLxmxsbDB79myu3EhL0tPTMWPGDISGhn7ElrUfT09PxMXF4X//+9/LT7WeTXHUqFE4d+4cC8ZeITExEevXr0fXrl25g4Obmxv09PQ+eluioqJw5coVrFq16pXL3rlzB2fPnoW0tDRGjBiBYcOGtbl8XV0dNmzYgCtXrkBdXR0eHh4wMzN7X01/Z+fPn+fmcjBMS1rquWnNpEmTYGFhgU2bNn22c+iYtpWWluL58+eIjY1FXV1dq4lrmOZKSkpw+fLlt6rvxjCtmTFjBg4dOoRt27Zh0aJF7d0cAMDRo0fB5/MRHh6Or7/+GuPGjUNVVRW8vb2hr6+PBw8eYNq0abCwsHjjbV+4cAHPnj2DmJgYiouLuZIfdXV1OHToEDp16oSQkBAsWLCA2/6xY8fA4/EQEREBJycnjBs3DkBjT3VWVhaePXsGeXl5LF68GOLi4rh+/Tr8/PywYsUKrF+/Hrm5udixYwdiYmJw4MAB6OjoYMeOHejUqROICD4+PlwNyD59+gj1Yu3ZswdiYmKoqalBQUEBd06ckZGBI0eOwNDQEOHh4Vi9ejVkZWXxww8/ICkpicsSGxsbixMnTmDbtm1QUlICj8fDvn37IC4ujtjYWAwfPhzffPMNcnJy8PfffwNo7Fk8dOgQ7O3t4eHhAaAx83dcXByICKWlpVi6dOnbfrzvzYMHD7B7927cu3ev7QWpyZwxIqKYmBjS1tammpqajzCKsmNLSEho8XEej0f6+voUHh5OREQlJSVkY2NDwcHBr1z3fYuMjKQxY8bQ0KFDX7lsQ0MDdevWjcrKyojH45Gdnd0r11m1ahUdOnSIQkJCaPTo0aSqqkqlpaXvo+nv7M6dO6Snp8fmJjDv1dSpU2nz5s3t3Qymndy5c4du3LhBN27coKSkpPZuziflzz//JBcXl/ZuBvMZSktLI3V1dQoKCmrvptD69evp3LlzREQUFBREMjIyxOPxaMuWLfTdd98REZGvry85Ojpy69jZ2dGuXbu4+z169KDLly8323ZVVRVJSEhQXl4eEREpKSlxx6Hp06dz55bbtm2jQYMGERGRl5cXnTlzhoiIgoODSVpamhoaGujcuXM0YcIEImqcBzx+/HiaPn0695yoqCidPHmS6urqyMXFhfr370937tyh6upq6t27N508eZKIiDw9Pbk5w1VVVdS7d2/asGEDERFt3LiRtm7dSkREdXV11L17d/L19SUiImdnZ9q+fTsREf3888+0evVqIiI6duwYmZmZEVHjXO3o6GgCwO2zq6sr7du3j4iI8vPzSUNDg44fP058Pp9+/vlnMjU1pZiYGMrOziZxcXF6/PgxERGZmppSRUUFERFt2bLltT/PDyU3N5f09PTIz8+vtUVutRqMERGNHz++Q+xIe7p9+zZNmjSpxecyMjIIAN2+fZt7LDY2lk6cOEFERMnJyTRs2LCP0UwiItq+fftrBWPZ2dkEgLKzsykrK4ucnJzaXL68vJz7oyIiKi4uJlFR0Q5xMOTz+TRs2DA6fPhwezeF+cw8fPiQNDQ0uMQSDMO8WmFhIamrq9OTJ0/auynMJ87c3JymTZtGFy9epKqqKu7x4OBgUldXp3///bfd2lZXV0ddu3YlPp/PPZafn09EREVFRZSWlkalpaW0fPlyLuAgev1gjIgoOjqaiBoTEikrK1NwcDDFxcXRwIEDuWV4PB4VFRVRfX09de3aVeiitKA9AwcO5IIaIqLQ0FACQC9evKD09HQCwCVP2bNnj9B564wZM8jLy4t4PB7JyckJne/u3r2bVFRUiMfjkYKCAmVmZnLPWVtb09GjR4moMYAuKiqijIwM+uabb8jV1ZWIGoOxPn36cOvk5eVxwVhBQQGJiopSRkYG9/yKFSvI3NyciIjWrFlDY8aM4Z7T19enixcvcq89ZswYSktLo/Ly8hbf24+luLiYBgwYwAWgrbgFAK1m6Ni4cSO8vLzw9OnTd+6iexfZ2dnYtGkTdu3ahd9//x3jx48HANy7dw9bt27F9OnT4evrC6BxUvmiRYtw9OhRzJw5E3379sWff/7JTTRPT0/H1q1bMWfOHHh5eYHH4wFoTFm8bt06+Pj4wM3NDdXV1Xjx4gV+/PFHPHz4EMuXL29W96lbt27Q1tbGt99+i6CgIACAiYkJvv76a1RUVMDFxQXx8fFYvnw5srOzwePxsH//fnh4eMDFxQUZGRmoqanB33//jenTp+PSpUsYNGgQRowYgcePHwMACgoKsGHDBpw6dQpz5sx5ZZHE16GmpgZlZWWsXr0anp6e2LlzJw4dOoT9+/dzXb9NycnJYfr06dx9eXl5SEtLd4iUxXv27EFNTU2b45IZ5m2YmZnByckJq1evbu+mMMwnY9WqVXB2dmZ1Spl3lp+fj+PHj2Pq1KlQUlKCra0tDh8+DGNjY+zbtw9jxox5q/qJ78OzZ89QVVUlVDJEUMpCRkYGR44cwa1btzBgwIC3KisCNCZAWr9+PfT09CArKws+n4/4+Hih7YmKikJJSQmZmZmorKxssT0ZGRlCJXoESYaaJm8SeHlYvri4OKqrq1FYWIiKigqh7ZiZmSE/Px9JSUkoLS0Vqs3ZdE6fpKQkNmzYgKysLBgbGwu1sbW5f5mZmeDz+UJJm8zMzFpsM9BYpkiQjOns2bMgIhgbG+PMmTMtLv8x5Ofnw97eHkOHDn2t6UOtBmM9e/aEh4cHnJ2d2ywi+6FJS0vjypUrOHnyJMaNGwdHR0ckJibi1KlTWLRoEby9vTFr1iwEBQXBwMAAFy9exK1bt7Bv3z5s3boVnp6eOH36NMrLy/HHH39g4cKF2L17N3bt2oU9e/YAAObMmQNzc3PMnDkTT58+xfnz56Guro4pU6agd+/e8PLyapZlTEJCAgEBAVBSUoK9vT1mz56N0tJSyMnJQU5ODrNnz4aWlha8vLygoaGBJUuWYPjw4fDw8ICamhomTJgACQkJiImJ4fTp0+jSpQtu3boFTU1NfPvtt6ivr8eWLVugo6ODKVOmYPDgwW0WEX5dT548gbq6Os6ePYutW7dCV1cXxsbG2LZt22tNIo2KioKtre17L6j6pu7du4fVq1fD19f3k6gJxXx61q9fj1OnTiEsLKy9m8IwHV5gYCAuXryINWvWtHdTmM+A4MS/srIStbW13PwobW1t/Prrr7C3t4eTkxOOHz/+0dumrq6O2tpaXL58mXssIyMDJSUlWLZsGXg8Hr799tu3PjdJTEzEzJkzsXTpUmhoaHCPa2ho4MGDB0KdJI8ePYKqqirq6+tx6dIlofYUFxfDyMgIDx8+5B6vq6uDhIQEDAwMXrs9Kioq6Nq1a7Pt6OrqQlNTE6Kios3mQwkCrQkTJmDo0KEYMmRIs+22Fqjq6+tDQkKi2eu1lQVZIDc3FwEBAdi3bx9cXV2Rnp7+Orv4Xj158gQDBw7EN998g82bN79WwpmWq7/+n59//hkPHjzAlClTcP78+XaZxKykpARjY2OIiIhg0KBBGDRoEH755RdUVlZy2fNGjx6NzMxM2NnZQUVFBdbW1pCSkoKdnR2mTJkCf39/FBQUoKioiEv0YGVlhaKiIgDAyZMnoa2tjSdPnqC0tBTZ2dnc67f1JpqamuLBgwdYu3YtvLy8EBISgqCgIHTv3l1o3YqKCvj5+UFdXR1A45eqS5cuqK2thY6ODmRkZGBlZQUA2LRpE1RVVZGYmAhVVVUsXboUioqK+P7771st1vu6fH19cfXqVfj7+6NPnz7YsmULVq5ciaioKOzduxcqKiptrs/j8XD48OEWe9A+puTkZEyYMAGHDh3i0qIyzPvWtWtXHDp0CNOnT0d0dDSXNv5TwuPxcObMGaSlpcHOzg4DBw5stsylS5cQFxcHCwsLaGpqIjY2Fs7Ozq1uk8/nIyoqCuHh4Vi8eHGz5/Pz83Ht2jWMHj2auzr7pamsrERgYCAMDAxgbGzc3s354PLz8zF9+nT89ddfUFRUbO/mMB1YeXk5GhoaUFlZibq6OlRXV6Ompga1tbWoqqpCfX09KioqWjzfEXQMPH36FJmZmairq4OLiwu2bduGa9eufbRjtKysLFxdXTFjxgysWrUKCgoKKCoqwtKlSxEfHw8RERFERkYiODgYRUVFiIuLg4mJCWpqaoSK2L98X0BQBuPGjRuoqalBVVUVkpKSMH78eFhaWmLUqFFYtmwZV4rKzMwMP/30E1xcXLj2FBYWYtmyZXB3d8fUqVOxZMkSaGhowN/fHwsWLICSkhIKCgq4dkhJSSEvLw8lJSVcOyoqKtDQ0AAAWLNmDbZv347vvvsO0tLS8Pf3x3//+1907twZLi4uWLJkCbS0tCAuLo7ExEQEBQXB3t4e8fHxCAwMhLy8PB4/fgwRERGkpqZCVVWVSypSVVXFdXjU1NRARUUFS5Ysgbe3N+zt7SEqKoqrV6/C3d0dwP//DglUVVVxo9c2bNgAX19fzJgxA9u3b4esrOx7/vRbR0TYvXs31qxZgx0eGS0NAAAgAElEQVQ7duC777577XVfeXa/e/duTJ06FZMmTYKfn1+LtV4+NFFRUaGgKCUlBdOmTcP3338PAFi2bFmr62prayMpKQkpKSno06dPi8vW1tZizZo1+P7776GlpcV1dwKtB2M5OTno1q0bpKSksHbtWjg4OMDBwQHr1q3jetyaZpNpaGhos50CKioqkJaWRm1tLebPn4+qqiqMGzcOkydPxoEDB4S6gt9EWloaXF1dkZ2dDSUlJXh4eGDZsmUwNzdHWloa5s+f/8pteHl5YcWKFe16gpWUlIQRI0bA09MTTk5O7dYO5sswevRo7vh39erVTy6rnru7OxwdHaGqqoqdO3c2C8YOHDiATp064euvv8b8+fPx008/4ebNm20GY4WFhbh69Sr27NnTYjAWHh6O6dOnIyUl5YsNxh49esRlf/vcg7GamhpMmDABAPDDDz9wJ0rS0tLc+YKghpvgMRERES5oa+mxpusAjb0kTUendO7cmTtZFxMTg7y8PPecjIyM0HAqoHF4fUu9FKKioq3WuXr5Nd+VoqIid04gCDheBxEJnSC3pK6ujqt9JyAIbpqqqalBdXW10GOCYEigoqKCCxDe9nc+n8/V1CsuLgbQmKGUz+dzn6uCggJERUW5z1JWVhaSkpLc96Gt4X3i4uIQERGBmZkZFixYgNjYWPTr1w8HDx6Evb19m+/V+7Jz504YGRnhzp07GDx4MH799VcAjaVRNmzYgPDwcLi7u6O2thbZ2dnIzMxEnz59UFxcjPT0dERGRuLrr79GfHw8hgwZAlVVVW7bo0ePxrJly/DPP/9gwYIF8Pb2RlpaGhQVFXHlyhV4e3sjODgYEyZMwKRJkwAA27dvR69evXD79m0MGjQIS5YsAQDY2dnhzJkz2Lx5M0xMTCAqKoqNGzeivr4eQUFBmDt3Lvz9/TFy5EiUl5dj8ODBuHv3LuTk5KChoQE+n4/U1FTMmzePm+JiZGSEoUOHctOG9u7di82bN2P16tUYNWoUli9fjj59+kBFRQUnTpzAyZMnuSlHO3bsQG1tLYYNG4apU6fiwIEDWLx4MY4fP465c+fi4sWLmD17NtatW4cDBw7A3d0denp6mDNnDuzs7JCTkwMxMTH06tULjx8/Rm5uLsaMGYOMjAxUVVXByMgIe/bsgZKSErZu3frKTob3JSMjAz/++COqqqoQFhaGXr16vdH6LdYZe1l9fT1cXFyQnp6OCxcufLSdE5g/fz5ERESwfft2AMDcuXNRVFQkNB701q1bsLe3x6BBgzB79mzMnj0bADBr1iyYmZlBREQEBw4cwMOHD7mD8q1bt2BjY4Pu3bsjNDQUvXr1grOzMwYMGIClS5dizZo1ePToUYvjTnfu3AkrKyuhlKUjR45E165dcfLkSfj4+GDXrl24f/8+SkpKoKysjLCwMAwePBgAkJWVhYqKCuTl5WH8+PFcL11hYSH09fWRnZ2NxMREmJubIy4uDuPGjYObm1urKV137NiBM2fOtFqzwc/PD9OnT0d5eTkkJSXB5/MxYsQIhIaGIjExEfr6+m1+Bn/99RdsbGy4cgdZWVlcD+DHEh4eDmdnZ2zcuFFoHhvDfEh8Ph9TpkyBlJQUfH19P6kaN1paWggLC4Ourm6Lz9vY2MDDwwPDh7d6+G9RYGAgpk2bhpycnGbP8Xg8iIuLIz09HTo6Om/T7M+CiYkJ1q5dywUqnyM+n4+pU6dCXFwcx44dE/rbaBogCE7EmwYIJSUlICIuGHg56BCcxAPNA4uysjJuzndDQwPKy8u556qqqlBbWyvUTsHrt9R+QdDwspaCmXch2F+gcZqDnJzca633cpDakpa211IwKSUl1eyCbtOgGRAOdJv+3jSgFQRSgHCQKQi0JCUlISsrC3FxcXTu3LnNoLc1I0aMaFY0XF5eHg0NDXB2dsaSJUuEyi/duHEDs2fPxtixY7FmzZov9kIQ83HV19dj//79WLNmDX777TcsWrToTYentl5n7GUSEhI4duwYPDw80L9/fxw+fPijXX0AGg+KTQ+kP/30EwYNGgQ3NzeMHTsWYWFh+Prrr7nnBQkw0tLS8PDhQ+zcuRPV1dVYvXo1Jk2ahFmzZiE+Ph5aWlooKipCQUEB/P39kZ6ejoyMDKiqquLZs2dQUVFBUlIS0tPTISIiInRioaenhx9++AEXL16Ejo4O8vPzERsbi8OHDwNo7OHKyMjgEnV8//33mDx5Mjw9PSEnJ4fQ0FBs27YNeXl5qKysREpKCvT19bF582a4u7tDRkYGR48ehZqaGkxMTDBlypQ2Dy41NTVC3bYv6927N/h8PpYvX45169YhOTkZBgYGyM/Ph4ODAzw8PNDQ0AADAwMMHTpUaF0fHx/cvHkT5eXl8Pf3R2lpKerr6+Ht7f1mH+Rb4vF48Pb2xrZt23D8+PGP+t1jGFFRUfj6+sLR0RFz5szB/v37uRORjiA/P587abGzs4OamhpKSkpw/fp1PH/+HAEBAdDX18eoUaO4dRoaGnD+/HkkJSUhJCQEJSUlmDBhAqqrqxEREYERI0Zwy4aGhuLp06ewsbFpc55BVFQUHj58yNUgbC1oraiowI0bN5CTk4OxY8dyx9WwsDCYmpoiICAAgwcPhr6+PtLT0xEaGopu3bph5MiRABpr6VRVVcHKygrV1dWIjo5Gp06dMH78eNTV1eHixYuwsbFpNq+1uLgYaWlp0NXVxfXr12FgYID+/fvjyZMniI6Ohr29PZeYiIgQEhKC1NRU2NnZoUePHgAaT+oFx85r165BR0cHgwYNQnx8PO7duwc7Oztoa2sLve7169eRkZGBr7/+mhuqDgAhISFISUnBsGHDuIth+fn5SElJgZycHOLj4+Hs7Iz4+Hg8fvwYUlJS6NevX4dIngQ0Hpd/+OEHFBcX49KlS80+b0lJSa4nuWkvF8O8DkFwKSkpCVFRUfTp0we//vorvvnmmxZHKIwcORKPHj2Cu7s7jI2NsXDhQixcuPCjDlNjvhxEhDNnzmDlypXQ19dHcHDwO42CeO0zChEREaxevRqHDx/GrFmz4Orq+l6vGrUmKioK0tLSkJGR4TLnWFhY4Pr16ygtLYWfnx8mTpwoNDlQREQEa9euha+vLwICAiArKwtlZWWEh4dDWVkZx48fh6mpKaZOnQo1NTUcPnwYT548QadOnbBlyxZIS0tDUlISU6ZMgaWlJS5dutTsH6ypqSlmz54NHx8frFy5EqtXr8aJEycwevRoAIC9vT2+++47+Pj4QF9fH/v378fcuXNx4cIFJCQkwMvLizuhk5aWRlBQEFavXg1TU1Nu6I+trS2OHTuGs2fPolevXtywzJeFhYWhsLAQffv2xblz51ocg2xiYoLz588jNTWVG3K1fft23L59GxMmTICvry9ERUWbBWJlZWW4f/8+VFRUkJqaitTUVBQWFmLixIlv+Ym+mYyMDNjb2+PmzZuIiopigRjTLgRj5NPS0vDDDz+0eeHjY7p37x5cXV0xZswYaGlpYeDAgQgPD4eMjAz69u0LIoKJiUmz7HaioqLo168fREVFoa+vD3Nzc+Tn52PhwoVwc3Pjllu1ahWkpKRgbGyMIUOGIDg4uMV2/PXXXwgODsasWbOQmJgIoOVgLCcnBwsXLoSdnR369u2Lr776CpmZmdi8eTNsbGywefNmnDt3DgEBAbh+/ToCAgIwbNgwbN68mWuXlJQU5s+fj169esHCwgIHDhxAeno6FBQUoKKigqCgoGY9gc+ePcOoUaMwb948+Pj4ID8/HzY2NvD29kZgYCCio6OFegd///13dO7cGT179sSAAQNw584dPH/+HE5OTnB1dcXhw4dRVFSE4cOHY8OGDbh27Rri4uJgbW0tNLzKx8cHwcHBOHPmDPr27Yvnz58DAFauXAkZGRn06tULgwYNQnh4OBITE2FjY4M//vgDf//9N7y9vfH8+XO4u7tj8uTJkJSURGBg4Ot/OT6guro6zJgxA7m5ufjnn3+aDQtkmHelqKgIRUVFLFy4EHFxcbh79y6cnZ3bHCquoKCA7du3IzIyEnFxcTA0NMTevXtbPCdimLd169YtDBw4EN7e3ti3bx+uXLnyfoajUwt1xtpSVFREU6ZMoa+++kqo7kBHMHDgQDpw4EB7N+O1hYSEkJKSUns3o8NpaGigvXv3kqqqKm3dulWongfDtJeqqioaN24cjRw5skPUILOwsKDz589z91etWkUmJiZE1FgLBwA9ffq01fW1tLTo+vXr3P1z586RoaEhETXWtxkxYgT5+fmRn58fmZmZccVDb926Rerq6kRElJOTQ1paWlRfX09Eje8RAKG6MwIzZ86kmzdvcvf/+usvKi4u5tYR1A7i8/lkbGxMJ0+eJD8/P/rll19IRESEysvLqaGhgbS0tOjGjRtE1FhkWFB7Jzc3lzZt2tTivnp4eNDEiRO5+3379uXq71RWVpKIiAiVlJTQ9evXacyYMdx+Gxsb07Rp04iosbhp0yKuQ4YM4Yqd1tfXk4SEBGVnZxMRkbGxMVeEtb6+noyMjGj58uUUFBREDg4O3PZ79+5NkydPJiKiX375hSsYS0QUERFBurq6lJKSQkREcXFxLe7bx1RUVER2dnY0YcIErj4Rw7xvqamp3DHlbT148IAcHR1JU1OT1q9fz9XeYpg3VVtbS8eOHaMBAwaQkZER+fn5va/z0rbrjLVFSUkJJ0+exMqVKzF16lRMnjwZqamp7x4VvgcVFRXNxot3ZIKMQvSWtSg+R1evXkXfvn3h5+eHwMBALFy48JOap8N8vqSlpXHu3DmYmJjAysoKSUlJ7daWqqoqxMTEoFu3btxj9vb2iIuLQ1lZ2Vtts+nfWVhYGAwMDNCvXz/069cP58+fx86dO5utc/v2bXTt2pWbW9LWletbt25BS0uLu//zzz9DUVGRm8ciqHOTlZWF4uJiDBgwAP369cOiRYvw9OlTdOrUCWJiYpg9ezY3JPzZs2dITk5GbGwsjh071uoIAlFRUaGx/CoqKtx9GRkZiImJobCwEGFhYTA0NOT2+/Lly9yQ7Je3oayszN0XFxeHtLQ0CgsLuecFc3HExcUxevRoJCcnN9v+P//8g61btwJo/H41TUYxaNAg2NnZoXfv3vD09HzjSeHvW1xcHAYPHoz+/fvj9OnT7ZLQi/ky9OjR450zSPft2xcBAQEIDAzEixcvYGhoiBkzZnBTWRjmVfLz87FhwwYYGBhgz549+O233/DkyRM4Ozu/1/PSd5r4MGXKFMTHx8PCwgKDBg3Cr7/+yiWiaA/h4eEYOnQoXrx48Un8sZWVlSE+Ph7Tpk3D33//3SzL0Zfm0aNHGDVqFBYvXow///wTt27dYsVDmQ5HTEwM27Ztw6JFizB06FCcOnWqXdohJSUFKSkpoVIc8vLy7y0LnLi4OFJTU6Gnp8fdxMXFm104EmQLezlBQkv/qERERBAdHS30WEuBo4SEBPLy8iAjI8O9do8ePbgEDz/++CMuXrwIPz8/jBo1CtOnT8fBgweRl5cHNTW119q/1ub9iYuLIy0tTWi/W5uQ/SYTtaWlpaGjo9Pq+9qSyspKHD58GEePHsVff/0lNIT0Yzt27Bjs7OywcuVKbNy4sUPNm2SYthgaGmL79u1ISkpCr169MHr0aAwbNgwHDhx4ZaZK5stTX18Pf39/TJ06Fb169UJKSgquXLnCJZH7ELVt3/loKi0tjeXLlyM2NhY1NTUwNDTEwoUL26XQmrW1Nfbs2QNPT0+uynhHJi8vj8WLF2Pfvn344Ycf3jpt/acuKCgITk5OGD16NMaPH49Hjx6xtPVMh7B+/XpMmDABy5Ytw65du3Dx4kVERUUhJycHs2bNwvXr17Fq1SrMnj37rXuj3paoqCgmT56MkydPco8JrtiJi4tz2eZayiInwOPxhJ7n8/moq6sD0Jhe+ebNmzhx4gSAxiuEe/fuhYiICIiIC8psbGxQXl6OY8eOAQDy8vIAoMU5xY6Ojvj9998RFxcHPp8PHx8flJWVcdsS/FRXV0efPn3g5uaG6upq8Pl8bNiwgZurp6mpiZEjR8Lb2xvjxo2Dq6srdu/eDQcHhzbfs6aBZHV1Nbe9pvvj6OiIS5cu4ezZswCAFy9eYP/+/a/chuD9a83du3cxd+5cjB49GlevXuU+t7y8POzbt4/bdtNt3L17F9HR0Zg4cSJOnz6N+/fvt7l/H0JJSQlmzpyJdevWITAwkGWyZT5ZysrKWLlyJdLT0/Hrr7/ixo0b6NGjByZNmoQLFy5wxz7myxQZGYn58+eje/fu8PLygq2tLVJSUrB///6P0zFAbzhnrC0vXryg//73v6SiokJOTk4dbk4Z0zHweDy6ePEiDRo0iHr27Enbtm2jqqqq9m4WwwjZtGkTiYuLEwCSlpYmBQUFUlBQIBkZGRITE6MuXbqQsbExaWlpUefOncnb2/ujtq+4uJjGjx9PK1eupAsXLpCbmxsVFBRQZWUlHThwgJSUlGjt2rWUm5srtF5DQwP9888/pKysTPPnz6f09HTKzs6mn376ibp27UrXrl0jIqKtW7eSjIwMqaio0IQJE6ioqIjy8/Np/vz5pKKiQpcvXyYiolOnTpGamho5ODiQl5cXaWpqkqenJ9XV1TVr77hx40hMTIz09PTo2rVrxOPx6NChQ6SkpESrV6+moqIiIiJ6+PAhGRgYkJSUFJmbm1NwcLDQtq5evUq+vr7c/Tlz5rQ6hv/58+c0fvx46t+/PyUkJFBMTAzp6enR1KlTKT8/n44fP05KSkq0YcMGqq2tpT///JOkpKRIVVWVpkyZQmVlZZSTk8PNlY6NjaUnT55Qr1696Ntvv6Xc3Fw6d+4cKSkpkZeXF1VXV9Pq1atp7NixtH37dlq1apXQ3LxNmzaRtLQ0qaio0KRJk6ikpITi4uLI3t6eLC0tublzN2/eJCcnJzp//jytXbuW/P393+Zr8tYCAgJIS0uL5s+fT5WVlR/1tRnmYygpKaFDhw6RnZ0dKSsr08yZM+n06dNUWlra3k1jPrD6+noKDg6m3377jXr27ElGRkbk6elJaWlpH7MZt4DXrDP2NioqKnDkyBFs27YNqqqqcHFxwZQpU15ZL4P5vCUlJcHHxwe+vr7o1asXFi9eDEdHRzYnjOmQ7t27BwcHh1ZrEQH/fx7R9OnTERgYiCFDhmDTpk1Cc7k+NEENow+RQryhoQHV1dXcfK7WEBFqamogLS0NHo/X5lCOmpqa155vVFxc3OJ+0f/1ZgmGy73qNd9UfX09amtrX7seVEv4fD6qq6tbTK9dX1+PmpqaV76vQONwxY+Zovv58+dYtGgRHjx4gAMHDsDW1vajvTbDtJesrCxcvnwZly9fRlhYGAYMGICxY8fCycmpWakM5tNUWFiIq1ev4vLly1yJEycnJzg5OcHc3Lw9mhQoIiJi/8GCMQEej4fr16/D19cXV69exahRozBjxgyMGjXqg4y7ZDqekpISnDp1Cj4+PkhPT8f333+PmTNnsvlgTIdXXFyMbt26tZoUSE5ODkZGRjh+/DgMDQ1RVVWF9evXY//+/Vi6dCnc3Ny+2OHHzKenqqoKO3fuxKZNm+Dm5obly5ezJB3MF6mqqgqBgYG4fPky/P390alTJ9jY2GDYsGGwsbHhag8yHVtxcTHCw8MREhKC0NBQJCcnY/jw4Rg7dizGjh372nOMP6CPE4w1JTgp9/X1RVpaGsaPH49vvvkGtra2rE7JZ6agoACXL1/GxYsXERQUxIJw5pOQm5uLiIgIhIWFISIiAvHx8ejWrRuSk5OFluvUqRMkJSXh7e2NuXPnNuvZTUpKwu+//47IyEisXLkSP/74IyQkJD7mrjDMa6urq8P+/fvx559/wtraGuvWrWuzwDfDfGni4uIQEhKCsLAwhISEQExMjAvMhgwZAiMjI3Zu0wFkZmYiMjISoaGhCAkJQXp6OgYPHswF0gMGDGgz4287+PjBWFNPnz7FhQsXcPHiRTx+/BgjR47EuHHjMGbMGHTp0uVjNoV5T5KSkvDPP//g0qVLQp+pk5MTG57KdEjZ2dmIiIhAeHg4IiIikJycDEtLS1hZWcHa2hrW1tZYs2YNvL29uUQNsrKysLW1xZEjR6CiotLm9h8/fgxPT0/cu3cPv//+O2bNmvXO6ZoZ5n3h8/k4e/YsVqxYgR49esDLywv9+vVr72YxTIeXnJyM0NBQhIaG4u7du8jOzoaZmRn69esHCwsL9OvXD8bGxux4/wGlp6cjOjoa0dHR+PfffxEdHQ1RUVEMGDAANjY2sLGxgYWFRUf/DNo3GGtK0Ity6dIl3Lp1CyYmJrC1tYWdnR2srKzeS5pm5v3LyclBUFAQgoODERQUhJqaGnz99dest5PpkHg8HhISErjgKzQ0FHV1dbC2tuaCL3Nz82Ypu69evQpnZ2fweDzIy8vj6NGjGDly5Bu9dkREBFauXIn8/HysWrUKEydOZD1lTLupr6+Hn58fPD09oampibVr12Lw4MHt3SyG+WSVlZXhwYMHXFDw77//IjMzE6ampjA1NYWRkRGMjIxgbGz8XmqofUmeP3+OhIQEJCYmIi4uDgkJCYiJiYGUlBQX+Ap+amhotHdz31THCcaaqqmpwd27d7kT/AcPHqBPnz6ws7PjuhibFsVkPp7MzEzcuXOHC8AKCgpgY2MDOzs72NnZwcTEhCXiYDqMqqoqREdHC/V8KSkpcYHXiBEjoKen98rtlJaWQkVFBfPmzcP69evf6eLQjRs34OXlhaSkJPz000+YM2cOVFVV33p7DPMmcnNzsX//fuzduxempqZYvnw5hg/vEP/6GeazU1FRgUePHiEuLg6JiYmIj49HQkICsrOzoaenB2NjY/Ts2RM6OjrQ1taGjo4OdHR0Pmqyno6grq4Oz58/x7Nnz5CRkYGMjAykpKRw75eMjAyMjY3Rq1cvGBsbw8jICGZmZlBXV2/vpr8PHTMYe1l1dTXu3LmD4OBghISEICYmBhoaGujfvz93Mzc3Z71n71lubi6ioqJw//59REVFISoqCmJiYrC0tOR6Lb/66isWfDEdRllZGe7du8cFXnfu3IGRkREXfA0fPhxdu3Z9q22npKRAX1//vbU1KSkJu3fvxtGjRzFixAgsWrSI9UwwH0x0dDT27duH06dPw8nJCUuXLkXv3r3bu1kM80Wqra1FUlISEhISkJycjIyMDDx79gzPnj1Deno6pKWloa2tzQVoKioqUFVVhZqaGpSVlaGiogI1NTUoKCi09660qbq6Gvn5+Xjx4gXy8/NRUFDA3RcEX+np6SgsLISGhoZQQNqjRw+YmJigV69en/s0l08jGHuZYKiRIEC4f/8+YmNj0aNHD/Tu3ZvrDjYxMYGBgQEbCvQK5eXlSEhIQGxsLOLj4xEXF4eHDx+iurpaKOAdMGDAp9j9y3zGXjXfy8rKqsNnMiwuLsahQ4ewe/duaGhowNXVFd9+++1rpTtnmLaUlZXh/Pnz2Lt3L/Ly8uDm5oZZs2Z97ic2DPPJKygo4IKzZ8+eIT8/H3l5ecjNzeUCmtzcXFRXV0NFRQXKysqQlZWFrKwsFBUVIScnBzk5OaH7EhISEBUVFQrgXr7fVGVlpVAR7Kb3i4uLUVFRgcrKSlRWVqK4uJj7vaKiAoWFhcjPzwcRQVlZGerq6lw7VVRUoK6uzgVfurq66NatW7PpAV+QTzMYa0l9fT1iY2MRFxeH2NhYJCQk4MmTJ8jMzBSKrgURt66uLnR0dL6YOU0lJSVIT09HRkYG0tPTkZaWxnX/FhUVccGriYkJjI2NYWZmBl1d3fZuNsMISU1Nxc2bNxEeHo7w8HDugoEg8Bo4cOAne/GFx+Ph8uXLOHLkCEJCQuDg4ID//Oc/GD169BdznGLeXW1tLQICAnDixAncvHkTdnZ2cHFxgZOT05d8ssMwn6W6ujrk5+ejqKiIC4RKSkq435veF5RnKS8v55JRAf+/RuXLOnfuLDSvTVFRESIiIlwAJy8vzwWACgoK6Ny5M3e/a9euXIDIvNLnE4y1pq6uDklJSYiLi0NSUhI3FjU9PR3Pnj1Dly5duMBMU1MT3bp1g4qKChe5q6qqQkVFpaOlweRUVlbixYsXyM3N5a6cCLqDBcFXRkYGREREhAJRXV1dbtytjo4OG2rIdDgNDQ14+PAh1+sVGBgIBQUFoV6vz3WOYklJCS5evIjTp0/j7t27cHR0hLOzMxwdHdmkb6YZPp+P27dv4/Tp0zh58iR69uwJZ2dnTJs2DcrKyu3dPIZhGKZ1n38w1hYiQk5ODhe0ZGdnIycnB/n5+VwXsCDIkZWVhbKyMuTl5aGgoMB1AcvJyUFJSYn7XTBvTUpKSmh4lIyMTLOr2xUVFaivr+ful5WVgcfjAWhMGCC4qlFRUcF1CQtuRUVFyMvLg5iYGNTU1KCmpsaNKVZXV4eysjIXZOro6LBhKUyHV15ejsjISC74unv3LrS1tblEG7a2tq9MI/85ev78OU6dOoUTJ04gJycHTk5OcHR0xIgRIyAnJ9fezWPaSXl5OW7evImAgAD4+/uje/fu+M9//oPJkyez4eQMwzCfji87GHsTJSUlKCgoQGlpKcrKyrigqLy8vFmXMNA45KisrIxbv6amBtXV1ULblJeX5woEvjxut2mAJycnJ9QlLCcnhy5dukBFRaXDz4dhmNbk5OQgKioKERERuHnzJpKSkmBmZsb1etnY2HT4yckfW0pKCvz9/REQEIA7d+5g4MCBcHR0xNixY2FoaNjezWM+sISEBAQEBCAgIAD379/HkCFDMHbsWIwZM+a1soIyDMMwHQ4LxhiG+ThSU1O5Xq/w8HAUFBTA0tKSC74sLS077HDgjqiyshKBgYHcybmkpCQcHR1ha2sLKysrqKmptXcTmXf04sULhIeHIzg4GFeuXAGfz+eCbyXIFswAACAASURBVDs7O5ZBmGEY5tPHgjGGYd6/l+d7BQUFQUJCQqi4soWFxWc536u9PH78GNeuXUNoaCgiIiKgrKwMKysrDB06FFZWVqzn7BOQmJjIJacJDw9HSUkJhgwZgmHDhmHUqFEwNTVt7yYyDMMw7xcLxhiGeXeVlZV48OABN+Sw6XwvKysr2NraQltbu72b+cUgIsTFxXEn9WFhYaipqYG1tTUGDx4Mc3Nz9O3bF126dGnvpn6xCgsL8eDBA8TExCAiIgK3b9+GrKwsrK2tuZuxsTG7YMEwDPN5Y8EYwzBvLj8/H2FhYQgNDUVYWBiSk5PRr18/DB06lDvhZ3WyOpasrCyEhoYiMjISMTExePjwIRQUFNC3b1/07dsXffr0Qd++fdnco/eMiJCamoqYmBju9vDhQ5SXl3Pv/aBBg2BtbQ1NTc32bi7DMAzzcbFgjGGYV3v+/DlCQ0O5W3Z2NqytrTF06FAMHToU/fv3/2Tre33JBEHCw4cPuUChtLQUZmZmMDQ0hIGBgdCNZW9sXUVFBZ4+fYrk5GQ8ffoUT58+RVJSEh49egQlJSUu8BIEvj169GjvJjMMwzDtjwVjDMM0l52dzQ05bCnZxqdcXJlpW1FRER4+fMgFFE1vCgoK6NmzJxec6erqQlNTE+rq6ujevftnnVCisrISWVlZyM3NRVZWFtLT07n3JTk5GWVlZTAwMBB6f3r27AkzMzMoKSm1d/MZhmGYjokFYwzDCGc6vH79OmpqarjEDyzZBiOQlZUlFJxlZGTg+fPnePHiBZ4/fw4xMTF0794dampq6N69O9TV1aGpqQk1NTUoKCg0u8nLy7fbvpSWlgrdysrKUFJSgry8PGRlZXH79OLFC2RlZYHP5wvtm46OjlDQxWp7MQzDMG+BBWMM86Xh8/mIj4/nUswHBQWBx+NxxZWtrKxY1jbmrZSVlQkFZ4KfeXl5LQY/paWlUFRUhKKiIhecSUpKNqu7KCcnx/XESkhICA2XrKioQH19PQCgvr6eq/UINAZcfD4fdXV1Qq9dXFzMvWbTwFBBQQGqqqpCQZfgJ5sDyTAMw3wALBhjmM8dj8dDTEwM1/N169YtKCoqcr1eDg4O0NXVbe9mMl+okpISoUCptrYWQGNgx+PxAADV1dWoqakB0Fg2oby8nFu/c+fOEBcXBwBISUlBWloaACAmJsb1vHXq1Eko8FJUVPxo+8cwDMMwbWDBGMN8bgQ1vgTzvW7fvg11dXVuvtfw4cPRvXv39m4mwzAMwzDMly5QRETEXry9W8EwzNtrqcZXr169YGVlhRkzZsDHx4fVk2IYhmEYhumgWDDGMJ+Q8vJyREZGcj1fMTExMDIywogRIzB//nycOXNGaL4NwzAMwzAM03GxYIxhOrC8vDxERkZyPV9JSUkwMzODtbU1PDw8YG1tDSkpqfZuJsMwDMMwDPMWWDDGMB1ITk4OwsPDuYQbycnJsLS0xIgRI7Bt2zZYWlpCUlKyvZvJMAzDMAzDvAcsGGOYdtRWgeV9+/bB3NwcoqKi7d1MhmEYhmEY5gNgwRjDfESpqalc4BUaGoq6ujou0+HcuXNZgWWGYRiGYZgvCAvGGOYD4fF4SEhI4Hq+goKCICEhwRVYXrZsGSuwzDAMwzAM8wVjwRjDvCcNDQ34999/ERISgpCQEEREREBLSws2NjaYOHEitm/fjm7durV3MxmGYRiGYZgOggVjDPOWeDweoqOjERwcjODgYEREREBHRwd2dnaYM2cOfH190bVr1/ZuJsMwDMMwDNNBsWCMYV7Ty8MOb968CSUlJYwYMQIuLi7w8fGBsrJyezeTYRiGYRiG+USwYKwVxcXFyM3NRX5+PvLz81FQUIDi4mJUVFRwt9LSUpSVlXH3y8vLufXLy8vR0NDA3S8tLQWfzwcASElJQVpamntORkYGnTp1AgCIiopC4f+xd95hUVxfH/8uIEjvRYSACCooKEU0ligIKgIaCyaKotjFjkF+saLGKMYuNuzdILFhiwUL2AKIgoIovUrvdct5/+DZed2wCBoDGufzPPuwM3PLuXdmh3vuPfccZWUoKipCQUEBCgoKUFJSgrKyMnOsqqoKTU1NaGhooF27dtDU1IScnFwL9czXg0AgQHx8PKN83b59GyoqKnBwcICLiwu2bt2K9u3bt7aYLCwsLCwsLCwsXygcACCi2wDsW1mWFoHP5yMrKwtpaWlITU1lPtnZ2Xj79i2jfMnLy0NbWxuamprQ0tKCpqYmlJWVoaSkxChFioqKUFFRYY7l5eWZelRVVUXqVVFRYbzk1dXVobKykrnG5XJRUVHBHDel9BUXFzNyvn37Fnl5eeBwONDW1mZkNjAwgKGhIQwMDJjv7KpN0wi9Hd66dQuhoaFQVlaGg4MD+vbtC3t7e+jp6bW2iCwsLCwsLCwsLF8+oRwOZ9B/VhnLyMhAfHw84uPjERcXhzdv3iA1NRU5OTmMstKhQwdGUWnfvj10dHSgqakJTU3NLy6wbmVlJXJzc5nVPKGSmZaWxiieNTU1MDQ0RIcOHdClSxd06dIFXbt2RZcuXaCiotLaTWgV3qd82dnZQV9fv7VFZGFhYWFhYWFh+e/x31DGSktL8fTpU0RGRiIuLg5xcXF49eoVFBUVYWpqClNTU5iZmaFTp04wNDSEvr4+2rRp09pitwoVFRVIS0tDcnIyXr16hfj4eLx8+RKvXr2CgoICzMzM0KVLF1hYWMDGxgbdunX7z/XVu8rXnTt3oKSkhL59+6Jfv34YOnQovvnmm9YWkYWFhYWFhYWF5b/Pl6eMVVVVITo6GpGRkYiMjERERARycnLQo0cP2NjYoGvXrsxKj7KycmuL+0WRmZnJrCQ+f/4cERERSElJQbdu3WBjY4OePXvCxsYGXbp0gYSERGuL22wSEhIQGhqKO3fu4O7du1BRUcHAgQOZj66ubmuLyMLCwsLCwsLC8vXx+StjVVVVePjwIcLDw/HgwQM8evQIBgYGsLa2hrW1Nfr164cePXpAUlKytUX9T8LlchETE4Pw8HBERUUhKioKmZmZsLW1ZUz5evXq9VmtnqWlpeHOnTsIDQ1FaGgoJCUlYW9vz3xYhxssLCwsLCwsLCyfAZ+fMsbj8RAWFobbt2/j7t27eP78OaytrWFnZwc7Ozv06tWL8TrI0joUFBTg3r17uHv3Lu7cuYPs7Gz0798fdnZ2GDJkCExNTVtUnry8PNy7dw+3bt1CeHg4CgoKMGDAAEZZ7Nq1a4vKw8LyuVBbW4uqqirU1NSguroa1dXVqKmpQWVlJerq6lBRUQEul8t4fhUeA2DSAqIOhogIJSUlTB3veokVlvtu3X/n786KmpL9Y5GXl2/Wvl8FBQWxk0nveriVlpZmnDNJSkpCSUmJSfeuY6Z3y5KVlUXbtm0BAG3atIGCggKkpKSgqKjIHMvIyEBOTo7xrivM01zZWVhYWFi+eD4PZay8vBzXr1/HxYsXcf36dXTs2BFDhw7FwIED0bt3bxEX8CyfH0Jl6M6dO7h69SqkpaUxYsQIDB8+HH369Pnkq5YVFRV4/Pgxs+/rzZs3zEqdg4MDrKysmMERC8vnTm1tLSorK1FSUoKKigpUVlaisrISxcXFqKysZM4Jj4XnSkpKIBAIUFJSAj6fj7KyMvB4PJSXlzMKj1ChEA7uFRUVISUlBSUlJUhKSkJZWRkSEhJQVVUFh8MRceIjTAOIKhZChULIu15j31VG/h6+Q4hQEWmKdxWgj+FdxfB9vKuAvktVVRVqa2sBvF8ZfTeEiVDpBcDcCyHv3i+BQIDS0lLmvgnLF3rZFSqiwv4U3jfh/VJRUWH+vuvJV3gsLy8PeXl5qKqqMt+FIVFYRY+FhYXls6L1lLHi4mKcPXsW586dw6NHj9CvXz+MGDECrq6uaNeuXUuJwfIvEB0djUuXLuHSpUvIyMiAs7MzRo8ejaFDh0JK6sPD2glNVYUrXy9evEDPnj0/WzNJlq8HLpeLkpISFBcXo7i4mPne2N/y8nJGmSotLUV5eTnatGkDeXl5KCkpQUlJiRk8vxtr8N1j4XUVFRVGsREqLsKVlneVJ5YvF+HqpFAxFCqYQgWwpKSEeZ6ECrpQYS8vL0dpaSlz/d1jPp8PBQUFqKioMM+ToqIiVFVVoaqqChUVlSb/su9cFhYWlk9CyypjPB4P169fx7Fjx3Dz5k0MHToUY8aMwZAhQ5o1U8ry5ZGRkYFLly7h9OnTSEpKwrhx4zB58mRYWFg0mofH4+H58+fMytejR4/QpUsXZuWrf//+rKkqyyeFz+ejoKCACe4uDA9RUFDwXgWrrq6OGaA2NXhVUVGBsrIyM/gVKl/sfleWlka4IldWVsYob6WlpU1OJrw78SAjI/PeZ15DQwOamprQ1taGhoYG82GfdxYWFhYRWkYZe/XqFQIDA3H69GkYGxtj0qRJcHNzY70dfmUkJibi+PHjOHbsGFRUVDBp0iRMnjwZioqKePbsGbPyFR4ejo4dOzLKV9++fVlTVZYPoq6uDgUFBSgoKEBeXh7y8vKY4/z8fOTm5oocl5SUiAwYhYHTNTQ03qto/RMzOhaWLxmh6WxjCtvff3v5+fkoLCxkFDXhR0dHh/muqakJLS0tJtanhoYGuwLHwsLyX+ffVcbu3buHTZs2ISoqCtOnT4eHhwc6duz4Katg+QIhIty/fx8HDx7E1atXwefzoaenhyFDhsDe3h7fffcdu1LKIhYej4fc3FxkZWXh7du3yMzMZP7m5uYyf4uLi5kBnpaWFrS0tMQeCwd8Ghoard00FpavgndXoP++Cp2fn4+8vDzk5+eLKG86OjrQ09ODtrY29PT0oKOjg/bt26Ndu3bQ1dWFtrb2R5nAs7CwsHwGhHI4nEGf9A3G5/MRHByMTZs2obKyEt7e3ggODmbNylgYOBwOBgwYgAEDBiA7OxtbtmzB0aNHkZWVBW1tbVYR+0qprKxEamoqUlNTkZmZiZycHEbpysrKQk5ODgoLC6GlpYX27dszAzIdHR3069dPZMCmra3d2s1hYWERw4dMfhAR8vLyRCZesrKyEBMTg2vXrjHH+fn50NDQYJQz4V9dXV3o6enB0NAQhoaGkJOT+5dbx8LCwvJxfLKVsStXrmDJkiXQ0NCAj48PnJ2dWa92LM2ivLwcBw8exLZt22BtbY0NGzbAxMSktcVi+YSUlpYiLS0NaWlpSElJYb6npqYiLS0NVVVVMDQ0hIGBAfT19ZnB1LsDLG1t7S8q4DgLC8u/j0AgQG5uLrKzs5GdnY2cnBzme0ZGBvOeUVBQgIGBAfOeEX4XHr8bsoCFhYWlhfg0ZopxcXHw8fFBcnIy1qxZAzc3t08qJcvXQ11dHfbs2YN169Zh5MiRWLt2LbS0tFpbLJZmwOPxkJqaijdv3uD169dISUlhFK20tDTw+fwGg593B0Sampqt3QQWFpb/MHl5eSITQMLvwmMpKSmRd5ORkRFMTEzQqVMnGBgYsKaQLCws/wb/TBkrKyvD4sWLcfXqVfj5+WHKlCmspySWT0JhYSHWrFmDM2fOYPXq1Zg5cya7yvqZkJWVhdevXzNKl/CTnp4OXV1dZvBiZGQkMrB5Nx4VCwsLy+dGUVERo6SlpaUhKSmJec/l5OTAwMAAnTp1Yj7Cd52urm5ri87CwvLl8vHKWHh4ODw8PODk5AR/f/8vYp9PXFwcRo0ahejo6GZ750tMTMTmzZuxZ88esdejoqKwbt06uLq6wtPT81OK2ywePnwIOTk59OjRA8+ePcO1a9cgLS2NgoICrFix4pPayJ88eRKDBg2Cjo7OJyuzKRISEuDh4QFNTU0cPHiQ3QvUQnC5XMTHx+PFixeIj49nBiRv3ryBoqJig8FI586dYWRkxAaTZWFh+U9SV1eHpKQkJCQkiExEJSQkoKqqCiYmJsz70NTUFObm5ujcuTPrDZKFhaUpPlwZ43K58PPzw5EjR7B//34MGzbsX5fyU1FVVYVLly7hxx9/ZM69fPkSXbt2FZv+9evX2Lt3LwIDA1FRUdFouYMGDcLIkSMxd+7cTy7z+7h27Rpyc3MxefJkZGdnY+DAgYiNjYWMjAzWr1+PxMREHDx48JPVx+Vy4ePjgxUrVkBdXf2TldsUPB4Pa9euxf79+7F3714MHz68xer+GsjNzUVMTAyeP3+OmJgYxMTE4PXr1+jQoQPMzc1hZmYmongpKiq2tsgsLCwsnw1lZWXMZFVCQgLi4+MRExODtLQ0dOnSBRYWFjA3N0f37t1hYWHBmt6zsLC8y4cpY0VFRRg9ejQUFBRw8ODBL/6FcuHCBVy7dg379u1rNM2DBw8wZMiQ9ypjzs7OcHJyalFlLCsrC+PGjcP9+/cBAOvXr8eDBw9w+fJlAEB6ejo6duyIlJQU6OnpfbJ6Y2JisG7dOvz++++frMzm8vjxY7i7u8Pd3R2rV69mzRY/EB6Ph5cvXzIKl1D54vF46NGjB8zNzWFhYQELCwt07doVbdu2bW2RWVhYWL5YqqurRd65wveutLQ0LCwsGOXMwsICZmZm7J40Fpavk1AOhzOoWa7JsrKy0KdPH9ja2uLixYstroglJyejf//+WLhwIaqqqrB06VLY2Njg1q1bAIBz585h1qxZAICnT5/Cz88PJ06cwLRp01BeXg4ej8esiuXl5SElJQU//fQTnj17ht9+++0fy1dVVYUFCxagV69e2Lp1K3O+pKQEGzZswK5duzBz5kw8ePAAQL3J5IgRI3Dz5k1UV1dj8+bNcHR0BI/HQ1xcHHx9fXHixAlMmDABM2fObFDfli1b4OLiwhxnZmaCz+czx3p6eiAiREdH4/z58xg7diwuXLiAwYMHw9LSEkFBQQCAJ0+ewMvLC2FhYVi0aBH69euHkJAQPH78GKNGjYKTkxOSkpKYci0sLJCcnIzo6Oh/3GcfSu/evfH48WPcvn0bkydPFmkvS0Nyc3Nx8eJF/PzzzxgwYADU1NTg7u6O69evQ0NDA97e3nj69CkKCgpw69YtbN26FZ6enrC2tmYVMRYWFpZ/iKysLGxsbDBlyhRs27YNoaGhKCwsREREBBYsWAA1NTVcuXIF48aNg7q6Ouzs7LB06VKEhIQgPz+/tcVnYWFpaYjoNjVCVlYWmZiY0ObNmxtL0iLMmjWLJk+eTEREeXl5JC0tTampqUREdPnyZbp58yYREX377bcUHBxMRETff/89BQYGEo/Hozdv3hAAysrKIiIiLy8vmjVr1nvrDA8PJ3l5+femGTZsGI0YMYJKS0vp2bNnxOFwqKSkhHg8Htna2lJkZCQREb169Yrk5OToyZMnRERkbW1NR44cISKimJgYAkB1dXVUVFRExsbGNHr0aIqMjGTa8i4dO3akkJAQ5jggIIDU1NSopqaGiIh4PB5JSEhQUFAQpaamEgDas2cP8fl82rNnD7Vp04YSExMpOzubFBQU6Oeff6aamho6duwYqaurU0hICAkEApo5cybNmTNHpO7p06fTsmXL3tsn/yZVVVXk6OhIEydOJIFA0GpyfE7weDx68eIFHT16lGbMmEFmZmakpKREffv2JV9fX7p06RIVFha2tpgsLCwsLGIoLy+nsLAw2rBhA7m4uJCGhga1a9eO3NzcaNu2bRQWFka1tbWtLSYLC8un5zYAvHdlrKqqCiNGjMDkyZPh7e3dAmph48yePRsXLlxAdXU15OTkoKSkhKNHjwKodygyaNAgAMCpU6cwbNgwPH/+HIWFhXj79i0kJSXFBpr8VKZuffv2hZKSEiwsLNCmTRukpKTg/v37ePPmDaytrQEAnTt3hoODAwICAgBAJF7Su+YJqqqqMDIywnfffQdra2uMHj1apC4+n4+UlBQRRxpTpkyBqakpvv/+e+zcuRO+vr4QCATo1q0b2rdvDwAYMGAAJCQkMGvWLBgZGeHWrVto164dVFVVYW9vDxkZGVhZWaG4uBguLi7gcDiwtrZGamqqSP0aGhqIj4//JP32McjKyuLixYtITU3FihUrWk2O1oTL5SI8PByrV6/GwIEDoaqqinHjxuHBgwf49ttv8ccff6CkpATh4eHYsGEDXF1doaam1tpis7CwsLCIQUFBAf369YOvry9CQkKQl5eHW7duYejQoXjx4gVmzZoFDQ0N2NvbY+3atXj48CF4PF5ri83CwvKJeK+R8vz582FmZoalS5e2lDyNYmFhAVNTUwQHB6O0tBTr1q3Dhg0bMGXKFOjo6DCKVUVFBXbv3g1PT08YGhpCIBA0Wuan3nfE4XAgKSkJPp+PzMzMBp6UunXrhkePHjVZjoSERKOyERGISESZk5WVxb179/DixQu0bdsW169fh6WlJUxNTcW+sPX09MDlchuc/7tzBklJSdTW1oqck5KSavX9WrKysjh37hxsbW3Ru3dvEZPN/yqJiYm4cuUKbt68ifDwcBgbG8PBwQFLly5F79692YClXxHR0dGIjY2Fh4cHAKC4uBhjx46FnJwctLS0kJ2dDVlZWSgqKiIvLw/6+vrYu3evSBm1tbXYtGkTNDU1ERsbCzc3N3z33Xet0ZwPIjo6GmPHjkVcXBzzfr179y6io6Nx9epVDB48GD4+Pk2Wk5WVhZ07dyIqKgrq6upQVVVFdXU1Bg4cCHd39wbv7vDwcOzbtw+KioqQlZVFZWUlNDQ00Lt3b6irq2P//v3IyMjAjh07YGpq2qC+hQsX4uXLlxg2bBhGjRqFw4cP48GDB9DW1oaWlha4XC4GDx4MZ2fnDw5sfuLECZSXl+PIkSNYsmRJgwk8li8PDocDMzMzmJmZYcqUKQCA0tJSPHr0CKGhoZg3bx6SkpLQv39/ODo6wsXFBUZGRq0sNQsLyz+CxJgpXr9+nTp27Ejl5eUtvmbXGEePHqXevXvT4sWLSSAQUJcuXcjJyYny8/OJqN5cS1dXl549e0ZERBMmTCA/Pz8iIiouLm5gpujl5fXe+pprprhx40bmWFZWliIjIykyMpI4HA5lZGQw17y9vWnu3LlERNSzZ086ePAgERHFxcUxZopEREOHDqUdO3Y0WqehoSHdunVL7LWCggJq37493blzh4iIuFwuAaC4uDgmjYmJCWM+qa+vz5h4pqWlkYSEBJPu4MGD5ODgIFL+jBkzaMmSJe/tk5YiLCyMdHV1qbi4uLVF+eTw+XwKCwujJUuWkKmpKenq6tKMGTMoODiYNTn8ypkyZQp17dqVMdNNTU2liRMnMu8PMzMz8vb2JqL698GwYcMalDFt2jQ6fPgwEREVFhaSrq4uY/b9uRETE8N8r6iooHPnzolc79SpE9XW1lJmZibdv3+/2eXGxsYSALp8+TIR1Zvkd+rUidzc3ETSbdu2jXR1dSk2NpY5l5eXRzY2Nsw7fNeuXQSAPD09G9QTHx9P8vLyJCcnx9yzrKwsAkBBQUFERJSYmEiGhoY0b968ZstPVP9/rXv37kRU308vXrz4oPwsXy75+fkUFBRE06ZNIx0dHTIzMyNfX18KDw8nPp/f2uKxsLA0j8bNFAUCAXx8fLB9+/bPKoaYm5sbXr9+jXHjxoHD4WDmzJlQU1NjTBDLy8uRl5eHCxcu4MqVK0hJSUFKSgqSkpJQXV0NoD6gMABoaWnhxYsXePnyJXJzc8XWV11dDR6PByJqVKaioiIUFxcDACorK1FbW4vi4mJYW1tj1KhRWL9+PYD6OCWPHj1iZm0NDQ1x8eJFPH78GOfOnQMAXL16FQBQU1ODysrKRut0dXXFy5cvG5xPSkrC2LFjsXnzZgwcOFDk2rNnzwDUOzuxtrZmzCdra2uZvsnNzYVAIEBJSQmA+lXGv8uRmJgIJyenRmVrSfr16wdnZ+dP4oTlc4CI8PDhQyxYsAD6+vpYsGABZGVlcfz4cWRmZmLfvn0YPXo0a3L4FVNYWIja2lokJCTg5s2bAABpaWn89NNPYmMaqaurY968eSLnqqurcfjwYfTu3RsAoKamhv79+2PHjh3/fgM+kLi4OMyePZs5lpeXx8iRI5nj3NxcJCYmQlpaGu3bt0f//v2bXbYw3qTQTFxXVxejRo1CcHAw6urqAAB//fUXvL29ERAQgG7dujF5NTU1cejQIVRVVQEA5OTk4OjoiJMnTyI7O1uknj179mD8+PGQkZFhrAqEMSCFq2AdO3bEpEmTEBgYyNTdHKKiohjrD3Nz80ZDtbD899DQ0ICbmxv279+P7OxsHDlyBNLS0pgzZw6++eYbLFy4EI8fP37v+IWFheXzQKwydu3aNcjJycHZ2bml5XkvsrKyOHHiBKNIeHh4YNGiRcx1FRUVnD59GtnZ2VBQUMD27duho6MDCQkJ/Pnnn/D19UVERARqa2sxffp0dO7cGTExMWKDCSclJSE2NhYLFy5EcHAwysrKGqSJiYmBvb09FBQUkJOTg5s3b8LHxwdJSUng8/k4c+YMjIyM4O/vj0OHDuH48eP45ptvANR7RNTV1UVISAgmTZqETZs2oXv37ggPD0efPn0gEAjw5s0bsf3g7e3NeJIE6hXCM2fO4Pz58zh16hR++OGHBnny8vKwatUqJCYm4vjx4wCAO3fuwNPTEzk5OSgqKkJ8fDx8fX1x584d5Ofno66uDnZ2dnj69CkAICcnBzU1NQ0UvdZk5cqV2Lt3LzMo+hLJzMzE6tWrYWhoiJkzZ0JTUxN3795FVFQU/Pz8YG1t3eqmoSyfBwcPHsTy5csxfPhwxnNru3btYGFh0WieoUOHihzn5OSAz+eLmDDr6+sjIiICSUlJ+N///gc/Pz/4+vrC2NgY7u7uKC0tRUFBAbZt24Y1a9bg+PHjcHJygru7O0pKSuDr64s+ffpg06ZNDerncrkICAiAs7MzHj58iMGDB8PBwQF5eXlMmhMnTmDfvn3w9fXFypUrmQmpuXPnIjk5Gf7+/sjIyMDvv/+OESNGoLS0FG/evMGmTZtALhM5lQAAIABJREFURPD390dwcDBCQkLg6OiI7du3o66uDpWVlfD29saNGzea1b8ZGRnQ09NjApjv2bMH0tLSYuMbmpubi5gEenl5oU2bNti+fTtzrqioCNXV1c0KMfL27VtIS0tDUlJS5HxxcTHWrVuH3bt3Y+rUqcy7/+HDhzh69Cjy8vLg7++Pu3fvNquNLP89OBwOevbsiTVr1uDZs2e4ffs21NTUMHXqVBgZGWHt2rUNJglYWFg+M+hvZoo//PAD7d+/vxVW61iay7Fjx+jGjRtNphNnpvixLFu2jOLj4/9xOZ8aFxcXOnXqVGuL8cHcvHmTXF1dSV1dnebOnStijsXC8nd4PB5NmTKFiIhu375NHA5H7O/6XTNFcdTW1pKKigoFBAQw5xYtWkS9evUiIqJx48aRra0tlZSUUFZWFpmZmdGcOXOopqaGFi1aRJ07d6Y3b95QbW0tGRoa0pQpU6i0tJSSkpKIw+FQZWVlgzrv3btHkpKSdOXKFRIIBDRo0CDGhPzw4cPk4eHBpB09ejSNHz+eiIiOHDlCVlZWRFRvuhsfH08AGFPdhIQEAiDiWbVv3760YsUK5tjLy0us59XExEQCQOvWraOjR4+Sh4cH9erVi/F4S0RkZWVFXbp0abQvhRw+fJju3btHCxYsIGVlZSotLSUiog0bNlBUVBStXr2aVFVVmfRCs/mjR49SXl4eBQUFkZqaGu3evVukXD6fT7a2tvTXX38REVFSUhLJy8tTWFgYERH98ccfZGZm1qR8LF8v0dHR5OXlRWpqajRixAi6fbtR59ksLCwtT+Nmivfu3Wswm8ryeTFx4kRUVFQgJibmvenKy8sB1Js+/hPOnj2LcePGoUuXLv+onH+DoUOHtuiscEJCAlJSUj4qr0AgwPnz52Fra4uFCxdi5MiRSE9Px86dO2Fubv6JJWX5L3Hp0iX0798fxcXF6NGjBzp27CiyCtNcpKWlsWvXLqxevRq//vorNm3ahMuXLzOra9ra2jA3N4eysjJ0dXXh7e2NP//8EzIyMjAwMECHDh1gbGwMaWlpmJqaomvXrlBSUoKRkRGUlJSQlpbWoE5VVVXw+Xw4ODiAw+HA0tIS6enpAOqtBITecAFg3rx5OHXqFAoKCgD8v6MlCQkJqKioNNk+X19f7NmzB9XV1cjOzoahoeF7V5YlJCRw4sQJPHnyBDdu3ICtrW3zO/NvLFq0CJWVlQgMDASXy8XLly9hZWXVaPqbN2/i0KFDTIDgd00yAeDBgweIj49Hz549AQBGRkZwcnJivPKysDRFjx49sGvXLqSnp8PV1RVz587Ft99+i5CQENaEkYXlM6GBMlZYWAgul9ssswqW1mXkyJHvNU8C6veIzZgxA9evX0dmZuZH1+Xm5vbZ7kfo0aOH2D10/xZ37tyBkZERLC0tcejQIbEmrOKIiIjAt99+i/Xr12PZsmWIjY2Fp6cns3+EheV9BAcH49WrV/D398fGjRthZmaG48ePM/tgP4Tx48fj1atXGDJkCKZMmYLc3FyMHz9ebFpdXd1G3Wg3xwOrOCQkJJiBYHZ2tkh4D+F7RmhW9aEmui4uLtDS0sLRo0cRFBTUaLuEWFpa4tSpU6iursaECRNEPPB2794dycnJzd7HZWBggLFjx2L79u04c+YMxo4d+97033//PXx9feHh4SESrkRIVlZWA7PFrl27Iisrq1nysLAIkZeXx9SpU/HixQv4+PjAz88P/fr1Q1RUVGuLxsLy1dNAGSsqKmIdBPyHmDp1Kvbt24eff/75P6tgq6urf9SA9GPhcrlo27Ytnj17hvnz50NbWxvOzs4ICQkRO2itqqrCrFmzMHLkSMydOxdPnjzBiBEj2H1gLM0mMjISxsbG2LBhA/M5cuQIACAwMPCjylRTU4O1tTX8/f3h4ODQ6F7Q1NRU9O3bV+y1TzGz3rVrV5EBYXV1NWRlZWFsbAwOh/PBdXA4HPj4+GDr1q3Izc1lYi2+Dw0NDZw9exY3btzAypUrmfNeXl7g8/k4ePCg2HxC508CgQB8Ph8A4OPjw7jO/6f7rrt27YqSkhIkJycz56qrq9lVdJaPRkJCAqNGjUJkZCSmT5+O4cOHY86cOYwjLxYWlpangTImKyv7j03aWFhakqqqKkhLSyMqKor5xMTEIDk5mflkZ2ejuLiY+YiLs9ZcuFwuM3teWVmJmpoaXLt2DRMmTICmpiZmz57NeK9MSEhAr169UFtbi/j4eEycOJFVwlg+mDVr1jRwIqGqqopBgwZh27ZtKC0tBVCvHBUWFqKoqKjJMgUCAbZu3YrExEQcO3ZM5Nrz58/B5XJRWlqKU6dOMQHW/+7p9e3bt0xdPB4P1dXVYleRhB5ahb+7/Px8xoR67dq1OHXqFDIyMgDUr+YvX74ccnJy0NbWRmpqKl6+fIn4+HimbqEJo7DdwrKEjB8/HlVVVbC0tGy0/cIJHKH8tra22Lp1K3799VecPHkSAGBjY4OAgAD4+PiIeE/MyMiAn58fI0dqaioSExMB1K/UOzo6Yvr06cxvvbCwEFVVVcyqoTBfU/fJ3NwcEyZMwC+//AKg3ivvgwcP4OvrCwAoKytr0HYWlubA4XAwefJkxMfHo7S0FH369GGeYRYWlpaFA9Q78ABgD9S/7NXV1ZGXl8e4/mVh+Zw5d+4cfvvtNxEFi8vloqKigjmurq4WmWSoqKgQSa+srMy4mZaQkICysjJzrU2bNiIhHtq0aYOoqKhGFbo2bdpAQkICurq6KCoqwtq1axu4F2dhaS537tzBn3/+iQ4dOsDT05Px9BcTE4Pz58+juroaBgYG8PDwwOnTp5GYmAgJCQlYWlrCzc1NbJl3797Fy5cvYWZmBjs7O5FrixYtQnp6Onr16oXCwkJMmjQJZmZmyMnJwfHjx1FWVoYxY8ZAQkICQUFBUFBQwMSJExEVFYWHDx/C0NAQkyZNYv5/CAQC7N+/HykpKbC1tYW1tTUOHToEAJg0aRKMjIwQFRWFP/74Ax07doSysjLGjBkDoP53vHLlSmhqamLatGk4c+YMkpOTYWxsDBcXF1y4cAGpqakwNTXF8OHDoaqqyrRj2rRp2LVrF2RkZBq0PycnBydPnkRBQQFkZGQwevRoxuR7+/btyM3NxYgRI9CrVy8AwIsXL3Do0CG8efMG7du3h4mJCaZPnw4lJSXcu3cPN27cAIfDwZgxY9CjRw9ER0fD1NQUbdu2xf3793Hjxg3weDxoa2tjzJgxCA4ORm5uLmRkZODk5MSEGRAHn8/Hnj17UFFRAVVVVTg6OsLIyAjp6ek4e/Ys8vPzYWtrC2dnZ7FtZWFpDvv27cMvv/yCO3fuwNjYuLXFYWH5WgjlcDiDGihjAJh9LZ+TC/PPFS6Xi8LCQujo6KC2thaSkpIi+x9aEj6f32B/QWOUlZWBx+N9kElqSUkJFBQUWq19jeHt7Q0tLS3873//++gySkpKGHMogUDAzLgDDRW7Y8eOISAgQGRviRAOhwMFBQXm2pw5c/DLL7+IjQHFwvI5smjRIpSXl+PAgQOtLcpHU1BQgF27dmHVqlWtLQoLyxfDoUOHsG7dOjx//vyzijHLwvIfJpTD4QwSO6oeOXIkTp8+zSpjTXDmzBkcOHAAQ4YMQUJCAp4+fYqjR4+2uD1/WVkZtm/fjoiICFy6dKnJ9Nu2bcPbt2+hrq4OIsKSJUvemz4jIwNjx45FbGwsgHrvZzNmzPgksv9T+Hw+goODmx1HqDH+7qVNXV290bSXL18WUcQkJCSgoKAAPp8PJycneHh4IDw8HKWlpfD39/9HcrGwtDRlZWVfrKn6mTNnsG/fPkhKSjKmhiwsLM1jypQpCAsLw8aNG7FmzZrWFoeF5atBrDI2adIkdOvWDX5+fmjXrl1Ly/RZcfbsWbGmPjU1NZg2bRqePXvGLOkvXrwY2dnZjDLWWN5PTVZWFsrLy5l9Ge+juroavr6+qKioQJs2bWBnZ9ekMrZ161acO3cOOjo6WL9+PebMmQMnJyfo6+t/qiZ8NCdPnoSxsXGLutyvq6sDh8OBvLw8OBwORo4ciUmTJmHAgAHMyuT06dMRERHRYjKxsHwKkpOTYWBgAB6Ph/v37+O7775rbZE+iO7du6N///4YPXo0tLW1W1scFpYvjpUrV6J///6sMsbC0oKIjTOmra2NqVOnYtmyZS0tT6PU1NSAx+OJbFbm8/ki5mPvpuVyuWLd/xKRWFfk5eXlSElJYTxiAcCmTZtw4sQJsfIUFBSgsrISd+7cYc4tXbqUyf/777/j119/FVvP383bhLPQBQUFDdpTXV3dpEt6U1PTZntKrKioQF1dHRISEnDr1q0m3dVXVlZizJgxaNeuHTgcDnx9fSElJYU3b940q75/k/LycqxcuRJr165t0XrV1dXh6emJkJAQFBcX4+jRo7C3t2cUsYKCAvD5/M9CWWVh+RCMjIywcuVKrFmz5otTxID6d+GaNWvQvXv31haFheWLpEOHDqiqqkJxcXFri8LC8tUgVhkDgOXLl+P+/fsICQlpSXkaEBcXhyFDhmD+/PlwdXWFiYkJAGDPnj3YvXs3pkyZgnHjxjEzuWZmZli0aBE8PT1ha2uL/v37MwrOuXPnsHXrVixfvhzfffcd401rz5492LhxIzIzM2Fra4vMzEzk5eXhxo0bSEpKgr+/fwOznfbt22Pw4MGYOXMmlixZgqqqKqirq2PYsGGoqqrChQsXkJ+fD39/f+Tm5iIzMxOrV69GYGAgevTogStXrqCqqgq+vr4wMTHBhg0b8MMPP0BDQ4NxWR0ZGQk/Pz+kpKRgwIABn8T1rKamJszMzDB79my8fPkSmzdvxsaNG5nYOH9HXl4effr0YY65XC6kpKQ+C9fKCxYswJAhQxp1u/1v4e3tjYMHD2LgwIFi9+ipqKigpqbmizX1YmFhYWH5OqmqqgKfz4eSklJri8LC8nVBRLdJDI8ePSJtbW2Ki4sTd7nFGDduHDk6OhKPx6PExES6fPkybdmyhYiIamtrSV5eng4fPkxERN27d6d169YREVFxcTHp6+uTv78/vX79mmbPns2U2b17d/rpp5+IiGjgwIF07949IiJydXWlPXv2EBGRn58fjRo1qlG5qqurycvLiyQkJMjIyIjCw8OZa4cPHyZra2vmePjw4VRZWUlERNu2bSMNDQ0SCAR048YNatu2LZWUlBAR0d69e0lBQYFKS0tp4cKFtGPHDiIiun37NpWVlTUqy/bt26l///7v7Uc+n09btmwhR0dHkpOTo4yMDCIievz4MY0aNYoEAsF78xMRnT59mpYtW9Zkun+bgIAA6tatG5WXl7e2KGJxdHRknkkWFhYWFpYvgcDAQBo2bFhri8HC8rVwG3jPyhgA9O7dG5s2bYKTkxNSUlJaRjMUg4aGBkxNTSEpKYmOHTvizJkziI2Nhb+/P7Zu3YoVK1agQ4cOAIC2bdtCS0sLQP0KxejRoxEZGYng4GCkpaXB398f/v7+GDduHONO+M6dOzA3N0dwcDDy8vJEzBjfFxOqbdu22LVrF+7duwciwqBBg3D//v0GeXNzc/H48WPs3LmTWWX76aefUF1dDRkZGcjKyjKu1CdPnoyqqiq8evUKQ4YMwZIlSzB//nxYWlpCUVHxH/XjlClTwOFwcPXqVRgaGmLx4sUAgPPnz2Pbtm1Nxr/Kzc3F06dPW92WXGgCeunSpc/W49P69euxfPlysaayLB9HSUkJ8vLyPipveno6E+Ppa6empgbp6ekfnb+wsBBPnjxBRUUFqqurmfhg74OI8PLly0avFxcXi8Qvay61tbV49OgRE3z5v0ZKSorYQPL/FIFAgPT0dCYmXGuapH1I+6qqqpCenv5BgcBLS0tFvOOyNE56ejpWrVoldosFCwvLv8d7lTEAmDBhAv73v//Bzs4O8fHxLSFTkxQWFqJnz57w9fVlPgMGDBCbVl5eHkpKSigqKkKHDh1E8owePRoAcODAAfj7+2PkyJEN9vk0pqA8evSI+YfQr18/REZGQkVFBbt27WqQt6ioCFVVVfjpp59E6peTk2tQrrS0NNq0aQMlJSUMHToU9+7dQ2hoKGxsbP6RQvzkyROcPn0ac+fOhZSUFHbu3Ing4GDMnz8f33zzTZP7myoqKrBt2zb88ssvTDyu1uDYsWPw9vbGjRs3GAX8c8Ta2hqLFy+Go6Pjf3ag2NKsWbMGCxYs+Ki8Li4uje7//No4cuQIvv/++4/KGxUVhS1btiAmJgZdunTBwYMHmZhgjZGXl4dZs2Y1ugft5MmT0NLSQlpa2gfJUlpaCi8vL9TU1MDMzAwJCQkflP9LoHfv3rh+/fonLTM2NhbfffcdgoKCsGzZMtjb2+Pw4cOftI7mwOPxcOTIEXTu3LlZJt3379/H9OnTERYWBg8PD5H93eLgcrmYOHEiTExMoKKiAnd3939Fsf2vkJ2dDUdHRyxbtozdc8nC0sI0a1Q9a9YsrF27FnZ2drh169a/LVOTWFlZYc+ePcweqpqaGgQGBopN+/z5czg7O8PS0hKnT59mBsZEhJ07d6K0tBSzZ8+Gl5cXJCUlRQL5SkpKNvryfvHiBc6cOcMcq6mpwdzcnHGR/m7eDh06QEpKSiRuz61btxAXF9eg3ISEBBgYGMDExAR//PEHbG1t8fTpU5iYmPyjwWRGRga4XC4KCgoAAPb29vDy8sLu3btFPBGKmyHlcrnw9/fH0qVLmYCzDx48+GhZPgaBQAA/Pz+sWbMGt2/fbtLxyOfAokWLMGnSJPTs2RPh4eGtLc4Xz/r16z869tX9+/fh6en5iSX6MpkxYwZCQ0M/Ku/GjRvRt29fTJ8+HVFRUZg9ezb+/PPP9+bR0tKCu7t7o9fHjx8PgUDwwbH4Tp48CU1NTWaisFOnTjh9+vQHlfG5ERYWJuKwKT4+Hs7Ozp+0jsWLF2PixIn46aef8Ntvv2Hp0qXIzs5mrl+/fr1FVspycnKgpaWF5OTkZqVftWoVJkyYAHd3d0hJSTW5Irt7924sWLAAeXl5ePToEc6dO8dOyDTC3bt3YWtri1mzZmHOnDmtLQ4Ly1dHs5c4Jk6ciKCgIHh6esLHx6fFTH64XC4yMjKQkpLCeCGcP38+KioqYGVlhblz52LSpEkYMWIEk+f8+fNISkrCsWPHoKysjO+//x5ubm7o3LkzrKys4OXlhbFjx+K7775jYkTNnTsX69evR01NDW7cuIHIyEiYmJjg8ePHOHToUINZW2NjY8yYMQMHDhxARkYGLl68iMTERPj6+gIATExM8OrVK+zbtw9JSUlYt24d5syZg7FjxzIu8c3MzADUewU8ceIEkpOTsXTpUiZOzu3bt3Ht2jVIS0vD0NAQgwYNEttHPB4PycnJKCwsZMxO/s6AAQOgpaWFUaNG4Y8//oC/vz8UFRUxc+ZMDBkyBOPHj4enp2cDszoiwowZM3DmzBnY2dnBxsYGFhYWOH/+/Mfd0I8gLS2NMQF9+PBhi7qx/6f4+vriwIEDGDt2LHx8fMR68vzaET6zFRUVzGQIETUYEMrIyIisygoEAqSmpqKyslJklryoqAiZmZki51RUVETeWdXV1RAIBCgvL2/Uu6pw4uJ9VFVVgcvliryfhBAR8vPzxebh8/koKipi2pGSktKgHUB9zC9xjnuEJn1v375tkKegoADZ2dmNrhxISEhARkamQXkCgQA5OTnvbe/Lly+Ze6CtrQ1JSckGZYlrt7jVdCJCRkYGBAIBOBxOo1YIPB4PCQkJDZ6HFy9eMA50tLS0EBAQIFZZLywsbNAXVVVVACD2/rzvemFhYYP7LEybmZkp1rtvcXGxyCSfsE2vX79mngGgPqzAjz/+KPKcqqmpiawaCe97SUmJWLPO4uLiJhWpzMxM3L59m+kTBwcH9OjRA0C98jdhwoQGk5CVlZUN6uPxeKirq0NZWZmIMie8lpycjNra2kafQ319/Q+ybigpKUF8fDyys7ORlZXVpDWHubk5bGxsANSvMA4aNAivX79udn1fAyUlJVi0aBHc3d1x7NgxLFq0qLVFYmH5eqFGHHiIo7i4mNzd3alr164UHR39yXey/Z34+Hi6efMm3bx5k54/f86cLywspJMnT9Lvv//OOMYgIurVqxcFBATQyZMnKTQ0lPh8PnOtqqqKzp07R0ePHqW8vDzmfGJiIp09e5ZKS0spJyeHbt++TXw+n/h8PgUHB9OLFy8ayFVYWEivX7+mR48e0Z49e+jUqVNUWloqkubKlSv05MkT5jgiIoICAwMpMjKSOXfv3j1SVVWlly9f0vHjxyktLY25lpSURH/++ScFBQXRmzdvGu2j6Ohopo/u3LlDXC5XbLrc3Fzau3cv7dixg2JiYpjzoaGhtGXLFkpOTm6Qp6Kigin73U9ubm6j8nxKgoKCSEtLi1atWiVyL7808vLyaPr06aSrq0v79u2j2tra1hap1cnIyKAff/yRhg8fTmvWrCFnZ2fS19en+/fv06xZs8jS0pJcXFyIiCgzM5OmT59Ojo6ORERUV1dHHh4eFBERQWvWrKHdu3cTEdHx48cpICCAQkNDaciQIUREFBUVRX369KFff/2ViIg2bdpECgoKFBgYSD/88AOpqanR1atXGblWr15Nu3btorVr15KBgQFNnTpV5DdLVP9btrCwoAkTJpCnpycZGRmRubk587u4evUqbdy4kZYtW0aWlpaUlpZGiYmJ5OrqSmPHjiU3Nzdq27YtlZeXk4eHB0VGRtKqVato//79RESUlZVF06ZNozNnztC8efNozJgxVFxcTG/fviU3Nzeys7OjZcuWkYODAxkbGzMOgAICAujIkSN07do1sc6HCgsLacWKFdSxY0ciInr+/DlZWlrSjBkzaNasWdS9e3caOXJkg3w8Ho82bNhA6urqNHnyZPL396eCggL6+eefqUuXLky6kJAQ+u2332jp0qVkZWVF6enpREQUFhZGampqTLpnz57R9OnT6caNG7Rq1SricDiUmJjYoN6kpCQaMWIE/fXXXzRjxgzatm0bEREdO3aMbGxsaMCAAbRhwwZ6/vw5ubi4kImJCW3YsIFKS0spPj6e/Pz8aMuWLWRmZkahoaFUVFRECxYsIDMzM/rll19ISkqKHjx4wNRXXV1Nq1evJhUVFTp06BDJy8vT8ePHKTY2llavXk2bNm0iU1NTCgsLo+LiYpo2bRqZmZnRzz//TAMHDiRZWVk6f/48ERHl5OSQn58fbd++nbp3704nT54kIqL09HRycXGhJ0+e0Lx582j9+vVERHTo0CECQL6+vnT//n0KDw+nbt260YEDB4jL5dKKFStIRUWF9u/fT2PGjCEVFRWR/y8LFy6ko0ePkre3NxkbG9PMmTPp9evXDfp08+bNBIDs7e0pKSlJ5Nr27dsJAK1atYoeP35MNTU1tG7dOgoICCB7e3taunQpEREdPXqUNDQ0aNmyZeTm5kYqKirk7u5OAoGASkpKyMPDg54+fUrz5s2jS5cuNZBBSFxcHAGg6urqRtMIWbRoERkYGNDSpUupqKiIrl27RmPHjqWlS5dSQUFBk/nt7Ozo3LlzTab7GqipqaFdu3aRjo4OzZw5k/Lz81tbJBaWr5XbH6WMCTl69ChpaWnRihUrPiuPdr169WIGNF8CQmWMRZSEhAQaMWIEmZubiyjhXzpRUVE0bNgw0tfXp23btlFFRUVri9Sq/PLLL2RjY0N1dXVERGRubk4+Pj5ERFRWVkYcDodRNLZu3Ur29vZERBQTE0NWVlZUW1tLAoGAGfDZ2dlRaGgoERFdvHiRqcfZ2ZlRxt6+fUsAGO+nPj4+NG7cOCIiev36NamrqzP5jI2N6fjx42Jld3BwIG9vbyKqn+ixsLCgxYsXU1ZWFk2cOJFJ5+joSB4eHkRENH/+fOrZsydxuVxKT0+np0+fUs+ePamuro74fD5dvnyZyXP27FmmjKFDh5KnpyfTD506dWIGsHp6ekz7e/TowUySNTYIvnr1KrVv3545Hj16NLm7uxMRUXJyMgGgoqIisXk7duzIyEhU38eGhoZEVK9cC9tJVH8vhDK/q4zV1tZS165dmQmx8vLyRpWxkydP0pQpU4iI6PLly9SjRw/mmqenJ/n6+jLHmzZtosGDBxNRvfI4ZMgQ4vF4RES0atUqMjY2JqL6CR4FBQXKzc2lrKwsJo2QiIgIAkCxsbGUl5dHZWVlNHToUMbb7P/+9z/q2rUrEdX/H2zfvj0zubJ27VrS0dEhPp9Pbm5uVFhYSET1kwRycnLMhKDweQsNDaVOnToREVFpaSkBoNTUVEYWGxsbOnDgABHVK84AmIm5iRMn0sKFC5n+NTMzI6J6r7lKSkp08+bNBv0p5PDhw6SqqkqysrKMgktUP+nx7v1fu3Yt83sSKk4RERHE5XJJSkqKmcRISEggGRkZunbtGl2+fJlcXFxIIBBQRUUF3bp1q1E5mquMXblyhcaNG0dSUlJ06tQpIqq/x927d6fi4uL35iUiSktLIwcHhy96Qu9TUF5eTps2baL27duTi4tLi0yos7CwvJemvSm+Dw8PDzx9+hTp6eno3LkzAgMDm9xQ+2/D5XKRnZ39wd6WWpP09HRUVlY2ai7ztVFYWIj58+ejf//+6NevHyIiImBhYdHaYn0yrKyscOXKFVy8eBEPHjyAgYEB5s2bh9jY2NYWrVVo27YtdHR0mP1C33zzDRPAXFFREYqKiozprJSUFJPPxMQEdXV16NWrF8LDw+Hq6goA+P777+Hi4oK1a9diyJAhTPp39yMJv+vq6gKojxkojDkoNFsUBpd/Xzw9GRkZaGpqAgBkZWXxww8/ICoqCpcvX0Z+fj4CAwMRGBiIMWPGYNSoUQDqzc5MTEwgJSUFfX19dO7cGRUVFfj222/x+PFjODs7o6SkBDdv3hR57n/88UdcuHCBkV9NTQ1t27YfYSlqAAAXnElEQVQFAOjp6THyf//99xgwYAA2b96MYcOGiZX73X4E6p0GCftC2PfC8pri3bJCQkJE2v3jjz+KdRTy8OFD8Hg8pu8UFBQgISEh1kxx/Pjx2L9/P27evIlHjx4x96UxhGW8evUKSUlJOHjwIAIDA6Grq4slS5aAiKCmpgY1NTVoaWlBV1e3QaxANTU1APUBpDU1NfH69WukpaVh//79CAwMRIcOHbBw4UIA9c+AsrIys5d20qRJePv2Ld68eYNbt24hODgYgYGBqKqqwtatW1FXV4eRI0fi5MmTCA0NRVhYWIM2vdsP73tu9fT0GDPHsrIy5OXlgcfjQUJCAt26dXvv/8DJkycjLi4OdnZ2WLhwIfz8/MTKEBQUhIiICAQGBiIsLAz79u2DiooKpKSkICkpydzDTp06oU+fPoiKikLPnj3x7Nkz2NvbIykpqVHz+uZy+PBhHD58GMePH8fs2bPh6+uL0tJSXLp0CcuXL2f2aTcGn8/Hjh07cObMmVZ1PtWaPHv2DF5eXjAwMEBkZCSuXr2KkJAQxjyVhYWldZFqOknjtG/fHkeOHEF0dDR8fHywY8cOrFu3Dq6urq3y0nvy5Ak2b94MAIiJifnsPQKVlJRAVlYWJ06cwL179zBs2DCxHha/BsrLy7F7925s3rwZ48ePR1xcHNTV1VtbrH8NS0tLBAUFITMzEwcPHoSzszPat28Pd3d3uLm5QVtbu7VFbBX+vv8IQIM9OkC9Evf48WP89NNPcHBwwLZt2zB79mzMnz8fHTp0gJeXF65evYqbN29+UPgDKysrjB8/HgsWLMDEiROhqamJsWPHNiuvnJwcVFRUUFJSAkVFRcyYMaNZef766y94e3vDzs4OAQEBjGL57h4dfX191NbWiu2Ld1m1ahU6deqEhQsX4tq1a7h69SqjKPzblJSUQFlZucl2Z2dnM/usmiI5ORkLFy5kvNS+6zRJHEIlori4GNXV1Zg+fXqTITuaori4GLW1tc2+n0JKS0vh7u4OeXl5kTQZGRnw8vLC9u3bISMjg71794ptw4fg6OiI3r17Y8mSJRgyZAisrKzg4ODQIF1aWhokJSWhp6cHHR0dXL58GSNHjsSOHTtEFLJ3+/Hbb79F//79m5RBTk4OysrK0NLSQnR0NLy8vNC7d2+cOnXqo7138vl8LFq0COfOnYOkpCT8/PwQHByMyZMnQ09PDzt37myyjPXr12PBggX/6f8n4sjJyUFQUBBOnjyJvLw8TJs2DbGxsYwyz8LC8vnwSTQmS0tL3Lp1C/7+/vj1119hZmaGffv2id14/m/Sr18/uLm5wc3N7bNXxID/j4Pm5uaGMWPGfJWKWGZmJpYsWQIjIyPExMTgwYMH2LZt21fzj1NPTw+rVq1CSkoKVq5ciYiICJiZmcHBwQH79+9v0qHCf42mVteFs/0xMTHIzMzEnj17cOzYMWzcuBEAcPbsWbi6uiImJgbFxcWM18APWSkfOHAg5s+fz7zHmqvMPHv2DK6urrCyskJISIiIs4Dt27eLVaSio6ORm5uLwMBAHDp0CBs3boSOjg46deqE27f/35T87du3jMOhxvpE2P5x48YhJiYGCQkJePLkiVhZP9ZyQFw+4TkrKyvGkZEQce3u1q0bMjMzERUVBaDe2QMRie2flStXwsLCAvr6+uByuSL1E5HI8bvecM3MzFBUVITff/+duf7HH398VHw1c3NzZGZmijgtOnPmjNjfZnR0NAYMGIBOnTqhXbt22Lp1K3MtPDwcf/31F9asWQMTExMYGRmJtEm4Qtdc9+vvtl1KSgrOzs6YOnUqbGxssHPnzkaVuuXLlzPfORwOvv32W2Y18O8yWFlZYevWrcy9ycrKQlBQUIMy+Xw+4uPj4eTkhFu3bkFKSgpBQUFYvXo1tmzZ0qz2iKOiogKlpaWMh0k1NTXs27cPFy5cgIKCAtMHja3k7t69G6NGjWKcfSQnJ4t4q/yvkZWVhb1798Le3h7dunXDs2fP8MsvvyA5ORnLly9nFTEWls+Uf7Qy9necnZ3h7OyMsLAwbN68GatWrcLs2bMxa9asr3amn0U8T58+xdatW3Ht2jVMnjwZUVFR+Oabb1pbrFZDUlISTk5OcHJyQk1NDa5du4bg4GD8/PPP6NChA1xcXODi4gJLS8v/lKlNZmYmsrOzmcHf69evmQFDdnY2KisrkZSUBFNTUyQlJSEpKQmVlZWora3Fr7/+isOHD6Ndu3aMSd7hw4dhYmICMzMzGBsbw9bWFlVVVcjKysLLly/B5/OZeFS5ubkwNDREbGwsMjIyUFdXh5KSEixevBgODg7Q1taGhoYGHBwc0KdPH7Hyh4SEwNXVFS9evEBFRQU8PDwgJSWFwYMHo3fv3hg+fDgqKyuxaNEi8Pl8pKSkICUlBXV1dZCWlkZNTQ02b96MAwcOiLTj4MGDmDp1KpycnNChQwdcuHCBGdgLvfDV1dWhtrYWKSkpjHvw3bt3M8qLmZmZWDPL169fIy8vD7m5uVBTU0NycjKkpaVBRHj+/DkAICkpCcbGxiL5iouLkZ+fjzdv3jDnYmJikJOTg4KCAgwePBj29vbo1asXXF1dUVFRAR8fH0hISCAhIQFVVVXIz8+HhYUFZs+ejVGjRsHb25tZJQsICMCGDRsY80sAUFVVxaFDh8Dj8aCgoICcnBzs378fnp6eSEpKQllZGQQCASQkJNC5c2esXr0ae/fuhYODA1atWoWJEyfi3LlzaNOmDezt7aGvr4+rV6+iqKgIBQUF0NDQENs/QH2YETMzM2hra2PZsmX44YcfMGrUKHA4HAwbNgzt2rUDUG9qfu7cOXTq1AmbNm1iFKHNmzdjwoQJePjwIbS0tGBsbIzly5cjODgYR44cYcxNCwsLsWvXLsyZMwd6enrYvHkzhg4digEDBiAnJwexsbEgIpHn9ptvvsH/tXdvMU2efxzAvwUFpNCDPVAE/hQU5CCoU7A4EQpsaETNLpbFZNFdbFm2JbvyYpebu1iWmOxiWUyWZWNLzOISLzyMnVRkuhUFHVago6K0HIo9wNsjltL2/V+QPmspTnRiQX6f5E37CtQXaOnzfQ6/p6+vDy6XiwWhDz/8EA0NDVAqlZDL5Thw4EDcFO+8vDz88MMPEIlEePvttzE1NYWTJ0/i+PHjAGarUkokEnzyySd46aWX8NFHH7Hf6datWxEOh3HixAn2eK2trZBIJPjqq6/wzjvvYP369ejp6cGxY8fw6aefIjs7+6Gl+XmeZ9u7jIyMoKioKO5zxGIx9u3bh6NHj7LO3Zs3b+KLL77A0aNH0dHRgZKSEuzZsyduBLu1tRUff/wxvv76awCzATMyov68CIfDbGr0+fPnYTabsWfPHrz//vvYu3fvvDMNCCFLjwCYLeABoOFpP7jRaMRnn32GU6dOoba2FkeOHEFLS8szmzZDlhabzYbvv/8era2tcLlceO+99/DWW29BJBIl+tKWrFAohD/++APnz5/Hjz/+CLvdDq1Wi6amJjQ2NqKwsDDRl/jELBYLa4ytW7cOPM+z0Yby8nLcvXuXlfVet24dK58tlUpRWFiIoaEhmEwmyOVy1NbWQiAQwGAwwGQyIRAIYNeuXZDJZOju7obT6QQwuyXF8PAwAoEAW1uj1+sB/LNe7fjx4/jf//4Hu90Or9cLnU7H9rSK1tLSgp07d6K0tBQSiQS1tbVsDVUwGMSFCxcwOTmJhoYGqFQqDA4OwmQyAZhdJ6XRaDA5OQmTyQSTyQSFQhEzHcxiseDXX3+FUChEQ0MDZDIZJicncfPmTQCASqUCMDtqBgDV1dUYHh6G2WxGKBRCXV0dxGJxzDVbrVa2PjE1NRU5OTksyJWUlMBkMsHv9yMpKQkNDf+8JYTDYXR0dLCRS7VaDaFQiL6+PgCz00Z37doV8303NjYiKysLExMT+OuvvwDMjuDU19cDmB0pslgsaG5uxt9//40dO3bEPUdmZmbw888/o7i4GBs3bsSlS5ewZcsWmEwmtl5KIpGwEuZtbW3Iz89n+xBev34dBoMB1dXVKC0thcPhQE9PD3t8rVYbs2bM5/NBp9Oxc41Gw6a56nQ6GI1G1NTUoLi4GABw6tQpHDt2DCdPnsTg4CDq6+tjAl5/fz+6urpQXl7OrjEYDOKXX35BQUEBysrK0N7ejoqKCsjlchiNRhiNRuzduxfXrl1jQbWkpAQDAwPgeR4pKSlYv349DAYDgNnntFgsxueff468vDzYbDZ4vV50dnbi/PnzcQ3y3t5epKeno6urC36/H1qtNqYjrK+vD8PDw9izZw8EAgFGR0fR0dEBpVKJpqYmNuKWlpbG1glWVFSw4G+1WjEyMgKz2Yy8vDxUV1fH/V6B2SmT0cF+y5Yt84bjYDCIs2fPwmKxYNOmTWyE+N69e/jpp5+wbds2aDSauK+7cuVK3BY8kXWay9ng4CAuXryICxcuoL29nQXeffv2YefOnXFrIAkhS9olgUDQuKhhLMLn8+H06dP49ttvcfv2bbz22ms4fPgwqqqqFuu/JEvE9PQ02tra0NraiitXruDAgQN44403UFdX95/XcqxEY2Nj7I344sWLSElJwYsvvgiNRoOdO3eisrIyrkADWbhDhw7h3XffjQlFp0+fRm1tLZRKZczntrS0YNeuXfjggw+e9WWSJSISxiKhNFEaGhpw4sSJmKDxzTff4NChQzEjjU9TWloarl69ykImefpmZmZw69Yt6HQ6dHZ24urVqwiFQqwzrqmpiY3QEkKWpUsCgaDxmbTahEIhDh8+jMOHD2N4eBjfffcdXn/9dQQCAezfvx8HDx7E7t27YypHkeWL4zi0tbXhzJkz+O2337B161YcOXIEJ0+efKxiCiReTk4Oey0Bs1XjOjs7odPp8OWXX8JkMuGFF15ATU0NampqoNFo4kIEebiNGzfizTffRFNTExQKBcLhMJqbm+N+hqFQCMPDwzCZTAgGgxSAV6ihoSE4HA5wHAepVJqw6ygpKcGrr76K+vp6rF27FjzP45VXXlm0IDY2NoZAIIA7d+5QGHuKrFYrOjs78eeff0Kn06GnpwcFBQWoqanByy+/zAr0EEKeL89kZOxh+vv7cfbsWZw5cwZGoxHNzc04ePAgmpqaVkwBh+eF0WhEW1sbzp49ixs3bqCxsRH79+9HS0tL3PQusnjcbjeuXbvGelI7Ozshk8mg0WiwY8cOVFZWorKy8pHloFcyk8mEwcFBZGdno6ysbN4R3L6+PjalUqVSYdOmTc/6MkmCRU8ZFQgE0Gq1CV3PaTQaMTIygry8vEVvsEdPASwrK6PCEE+A4zjo9XrcunUL169fh06ng8vlgkajgUajQU1NDaqrq5GZmZnoSyWELJ5nN01xIaxWK86dO4dz586ho6MDarUaWq0WWq0Wu3fvpsbjEnPv3j1cvnwZ7e3taG9vR3JyMpqbm3HgwAE0NjZizZo1ib5EgtlF8pHRs+vXr0Ov16O3txdSqRSVlZWoqKjA5s2bUVlZiaKiIlpvQAghT1EwGITRaMTt27dx69Yt6PV63L59G06nk3WOVVVVsbWINH2fkBVlaYWxaMFgEDdu3MDly5dx+fJl6HQ6bNiwAXV1daiurkZVVdWyLlyw3MzMzECv16O7uxs6nQ7t7e0IhULQarWor6+HVqul38cywvM8hoaGoNfrWcOgp6cH4+PjKCkpYeGsoqICpaWltCaBEEIWwGKxwGAwsL+rer0eBoMBubm5MX9XKysrUVBQkOjLJYQk3tINY3MFg0F0dXXh999/R1dXF7q7u+HxeLB9+3ZUVVVh+/bt2LZtG9tLhDy5YDAIg8GA7u5udvT19WHDhg3Yvn07NBoN6urq5i1DTJY3n8+H3t5eNnWmt7cXBoMBfr8fRUVFKC4uZlXtiouLUVRURJUwCSEritvtZlUvBwYG2P07d+4gPT0dpaWlLHBt3rwZ5eXlK3IPUULIgiyfMDYfm80WExhu3LiBqakplJaWoqysDKWlpSgvL0dJSQny8/Np6H+OQCCAgYEBGAwG9Pf3s9u7d+9CrVbHBN0tW7bQtMMVzOl04s6dOzGNj8h5ZmYmC2nRh1qtXrTiAYQQspj8fj9MJlNc2BoYGIDP52OdUXM7p+ZuJUEIIY+wvMPYfDiOQ39/f0y4MBgMmJiYQHFxMfLz85Gfn4+CggJ2X61WJ7QK1mIJh8MYHx9nexiZzWZ2DA0NYWRkBIWFhSy4Rm43btxIG0WSBRsbG4sJZ5HDbDZDKpWy11n0oVar2T5VhBDyrHm9XvZeGP3eGDmcTifUajXrXIqeGUDFSgghT9HzF8YexuPxsA1XzWZzTEAxmUwIh8PIzc2FQqFAdnY2FAoFFAoFVCoVsrKyIJfLoVAoIJFIkJGRkbBRIrfbDa/XC6fTCbvdjvv378Nms8Fut8NqtcJqtbJ/Hxsbg0wmYw3fuQ3hwsJC2kqALKpIZ8Dchk7k9Zeenj5vUMvLy0N2djaysrISWp2OELL8hEIh2Gw2WCwWtvn03L9Dfr8/7r0x+qB1soSQZ2TlhLFHcblcGB0dhcPhwPj4OOx2e1zYsdvtcLlc8Hq9mJ6ehkgkglgsRkZGBjuiR9iSk5Nj1tOsXr2a7bHFcRz793A4DJfLxc5nZmbg9XrBcRy8Xi87XC4XC4MikYiFRaVSCYVCgaysLGRlZbH7ubm5NMJFljS73R4X1IaGhjA6Oorx8XFMTExAoVAgJycH2dnZyMnJgUqlQm5uLruNPO8JIc83nudhs9lw//59jI6Osk7H8fFxdmuxWGC32yGXy5GdnY3c3Nx5Q5dcLk/0t0MIIQCFsSfH8zycTic8Hg8LS263Gz6fD4FAgH2e0+kEz/MAZgtjeDweCASCmDL9KSkpMdO1MjIykJqaCrFYDJFIxIIe7TVCVppgMAir1YqxsbGYBtjo6CisVitGRkZgtVrhdDpZB0QkpMnlcsjlctZBETmXy+U02kbIEhEOh+FwOOBwOFinp81mY+dzX+tr166Ne62rVKqYDhulUkmbsBNClgsKY4SQ5S8QCMSEtMgot8PhYFN3I+cTExOQyWQsmEVGkqPDWnSAk0qlVIiEkAV68OABOI5jYSo6WEVej9Hha3JyEjKZjL3eFAoFlEolux8Z/Y7cpqSkJPpbJISQp4nCGCFkZeF5PiaczRfYIlOTHQ4HOI4Dz/OQSqWQSqWQSCSPdZ9GtMly43a74XQ6wXEcOI57rPtJSUmQSCSQy+VQKpUsWP3bSDVVOiaErGAUxggh5FH8fv+8Dc+FNFJ9Ph+kUilEIhGkUimEQiGEQiEyMjIgkUjYeWZmJsRiMftY9LlQKIRIJIJIJEJycnKifxxkiYlMgXe5XPD5fPD5fHC73WzqvM/ng8vlgsfjYedOpxNer5edcxwHt9sNjuPYc/NJOiBonTIhhDyWSwKBoJEmVhNCyL9IS0uDSqWCSqV67K8Nh8PgOA4ul2vexnKkQcxxHMxm8yMbz8nJyRAKhRCLxWy9aWpqKtLT07FmzRqkpaUhPT0dqampyMjIwOrVq5GZmYlVq1ZBLBYjKSkJUqmUrV2NFBpatWoVG8VLSkqK2S+JQuDChEIhuN1udh69Ztjj8SAYDMLlciEcDsPpdMbculwuFqoiRZymp6cxNTWFBw8ewO/3Y2pqCtPT0/B6vZiZmYHT6YTP5wPP8xAKhQsK+0qlMibcRz4uFoshkUggkUhoTSUhhDxjFMYIIWSRJCUlQSaTQSaTPZXHCwQCLLxFGv+RRnzkY/M14j0eD0ZGRjAzMzNvMOB5PqbKq9vtRigUAgAWAgCwoAfEVogFEFNNNhIAo0VC46MsZN9HgUDAgs7DRAotPcrcwkvAP1VtI6J/NpEwBMyOmj548ABA7PcXHW4B/GsAjg7VUql0QaE6OTmZVdelLUoIIWR5ozBGCCHLREpKClJSUhK2UX0k6AELGwl62Nf+m+jg8zA8zz9yrdHcyrUPEx0wI6KD5tzHiYwwAoBQKKSiEoQQQv4TCmOEEEIWJDU1NSa40H5NhBBCyH9Dk8MJIYQQQgghJAEojBFCCCGEEEJIAvwf7hUrackWTDwAAAAASUVORK5CYII=" alt="Procedures for failed check-in" width="100%" />
<p class="caption">
Figure 2: Procedures for failed check-in
</p>
</div>
<p><br><br><br></p>
<!-- <br><br><br><br><br><br><br> -->
<div class="figure"><span style="display:block;" id="fig:map-prep"></span>
<img src="data:image/png;base64,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" alt="Map of potential sampling areas." width="100%" />
<p class="caption">
Figure 3: Map of potential sampling areas.
</p>
</div>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-electrofishing-sites">Table 5: </span>Potential Phase 1 assessment, Phase 2 assessment, and Electrofishing Locations
</caption>
<thead>
<tr>
<th style="text-align:right;">
id
</th>
<th style="text-align:left;">
stream_name
</th>
<th style="text-align:right;">
utm_zone
</th>
<th style="text-align:right;">
utm_easting
</th>
<th style="text-align:right;">
utm_northing
</th>
<th style="text-align:left;">
watershed_group_code
</th>
<th style="text-align:left;">
pscis_assessment_comment
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
125000
</td>
<td style="text-align:left;">
tributary to Parsnip River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed upstream continuosly for 350 m to beaver influenced wetland area where walking became difficult. Then stream was visited again upstream at 1.6 km upstream from crossing then again at approximately 2.5 km upstream of crossing. Undercut banks provide areas of deep cover ad Large woody debris is scattered througout. Overhanging vegetationalso provides cover througout. Pools observed were somewhat shallow but were preseetevery 20 - 30 m or so. Minnowtrapping conducted upstream and downstream of crossing. Electrofishing conducted downstream of the crossing. No fish captured upstream of the culvert. First beaver dam located approximately 330m upstream of the culvert.
</td>
</tr>
<tr>
<td style="text-align:right;">
125179
</td>
<td style="text-align:left;">
Unnamed tributary to Missinka River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration with habitat for rearing and overwintering upstream. Surveyed upstream for 520 m with no barriers to fish passage present. Bull trout and rainbow recorded upstream. Some deep pools for overwintering and rearing. Large woody debris and undercut banks throughout. Sections of gravel suitable for spawning. Good flow. Surveyed downstream for 360 m. No barriers observed and none likely downstream of surveyed section due to gradients. Abundant large woody debris and gravels suitable for spawning.
</td>
</tr>
<tr>
<td style="text-align:right;">
125180
</td>
<td style="text-align:left;">
tributary to Missinka River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569664
</td>
<td style="text-align:right;">
6053048
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed upstream of PSCIS crossing 125186 for a distance of 515 m. Good flow and abundant cover. Large woody debris and pools throughout. Frequet pockets of gravel suitable for spawning. Good candidate.
</td>
</tr>
<tr>
<td style="text-align:right;">
125231
</td>
<td style="text-align:left;">
tributary to Table River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065140
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed for 600m to new bridge (modelled crossing 16603641). Some deep pools and bounlders, udercut banks, gravels throughout. Abundant large wody debris throughout. Some debris steps from 30 - 70 cms high. No barriers. Rainbow trout known upstream (FIDQ 2020). Good candidate for rehabilitation.
</td>
</tr>
<tr>
<td style="text-align:right;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534600
</td>
<td style="text-align:right;">
6067770
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
Two additional culverts at 0.9m diameter.
</td>
</tr>
<tr>
<td style="text-align:right;">
198667
</td>
<td style="text-align:left;">
Tsatchuka Creek
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
500641
</td>
<td style="text-align:right;">
6089777
</td>
<td style="text-align:left;">
CARP
</td>
<td style="text-align:left;">
Grate on inlet and beaver influenced wetland upstream. Inlet blocked by beaver debris with beaver trap on inlet. Potentially good candidate for leveler to maintain beaver activity without attempting to remove the animals. Ministry of Transportation chris_culvert_id: 1997066. 13:04:57
</td>
</tr>
<tr>
<td style="text-align:right;">
198668
</td>
<td style="text-align:left;">
Tributary to McLeod Lake
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
<td style="text-align:left;">
Abundant gravels, suitable for spawning upstream. Although flows are minimal, the streams does still have water. Models as having over 3 km of habitat upstream below 5%. Although no fish are recorded as present upstream it seems highly likely that this would be a fish bearing stream. Outlet drop is 80cm. Steep section of pipe at the inlet recorded as inlet drop. Ministry of Transportation chris_culvert_id: 1996852. 13:40:04
</td>
</tr>
<tr>
<td style="text-align:right;">
198692
</td>
<td style="text-align:left;">
Tributary to Kerry Lake
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
511735
</td>
<td style="text-align:right;">
6059316
</td>
<td style="text-align:left;">
CRKD
</td>
<td style="text-align:left;">
Nice little stream with decent flow for this time of year. Pockets of gravel throughout and healthy shrub and mixed riparian. Fish presence unknown, but seems likely due to proximity to Kerry lake with low gradients. 17:14:13
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fish_passage_assessments" class="csl-entry">
BC Ministry of Environment. 2011. <em>Field Assessment for Determining Fish Passage Status of Closed Bottom Structures</em>. Manual. Victoria, British Columbia: BC Ministry of Environment. <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf</a>.
</div>
<div id="ref-confirmation_checklist_2011" class="csl-entry">
Fish Passage Technical Working Group. 2011. <span>“A <span>Checklist</span> for <span>Fish Habitat Confirmation Prior</span> to the <span>Rehabilitation</span> Fo a <span>Stream Crossing</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf</a>.
</div>
<div id="ref-mcphail_carveth1993FieldKey" class="csl-entry">
McPhail, J. D., and R Carveth. 1993. <span>“Field <span>Key</span> to the <span>Freshwater Fishes</span> of <span>British Columbia</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
